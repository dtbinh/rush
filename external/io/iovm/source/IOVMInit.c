#include "IoState.h"
#include "IoObject.h"

void IoVMCodeInit(IoObject *context)
{
	IoState *self = IoObject_state((IoObject *)context);
	char *s;

	s = "Object do(\n"
  	"  /*doc Object inlineMethod\n"
  	"  Creates a method which is executed directly in a receiver (no Locals object is created).\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> m := inlineMethod(x := x*2)\n"
  	"  Io> x := 1\n"
  	"  ==> 1\n"
  	"  Io> m\n"
  	"  ==> 2\n"
  	"  Io> m\n"
  	"  ==> 4\n"
  	"  Io> m\n"
  	"  ==> 8\n"
  	"  </pre>\n"
  	"  */  \n"
  	"	inlineMethod := method(call message argAt(0) setIsActivatable(true))\n"
  	")\n"
  	"\n"
  	"List do(\n"
  	"	unique := method(\n"
  	"		u := List clone\n"
  	"		self foreach(v, u appendIfAbsent(v))\n"
  	"		u\n"
  	"	)\n"
  	"\n"
  	"	select := method(\n"
  	"		aList := List clone\n"
  	"\n"
  	"		a1 := call argAt(0)\n"
  	"		if(a1 == nil,\n"
  	"			Exception raise(\"missing argument\")\n"
  	"			return\n"
  	"		)\n"
  	"		a2 := call argAt(1)\n"
  	"		a3 := call argAt(2)\n"
  	"\n"
  	"		if(a3,\n"
  	"			a1 := a1 name\n"
  	"			a2 := a2 name\n"
  	"			self foreach(i, v,\n"
  	"				call sender setSlot(a1, i)\n"
  	"				call sender setSlot(a2, getSlot(\"v\"))\n"
  	"				ss := stopStatus(c := a3 doInContext(call sender, call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"				if(getSlot(\"c\"), aList append(getSlot(\"v\")))\n"
  	"			)\n"
  	"			return aList\n"
  	"		)\n"
  	"\n"
  	"		if(a2,\n"
  	"			a1 := a1 name\n"
  	"			self foreach(v,\n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				ss := stopStatus(c := a2 doInContext(call sender, call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"				if(getSlot(\"c\"), aList append(getSlot(\"v\")))\n"
  	"			)\n"
  	"			return aList\n"
  	"		)\n"
  	"\n"
  	"		self foreach(v,\n"
  	"			ss := stopStatus(c := a1 doInContext(getSlot(\"v\"), call sender))\n"
  	"			if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"			if(ss stopLooping, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			if(getSlot(\"c\"), aList append(getSlot(\"v\")))\n"
  	"		)\n"
  	"		aList\n"
  	"	)\n"
  	"\n"
  	"	detect := method(\n"
  	"		a1 := call argAt(0)\n"
  	"		if(a1 == nil, Exception raise(\"missing argument\"))\n"
  	"		a2 := call argAt(1)\n"
  	"		a3 := call argAt(2)\n"
  	"\n"
  	"		if(a3,\n"
  	"			a1 := a1 name\n"
  	"			a2 := a2 name\n"
  	"			self foreach(i, v,\n"
  	"				call sender setSlot(a1, i)\n"
  	"				call sender setSlot(a2, getSlot(\"v\"))\n"
  	"				ss := stopStatus(c := a3 doInContext(call sender, call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"				if(getSlot(\"c\"), return getSlot(\"v\"))\n"
  	"			)\n"
  	"			return nil\n"
  	"		)\n"
  	"\n"
  	"		if(a2,\n"
  	"			a1 := a1 name\n"
  	"			self foreach(v,\n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				ss := stopStatus(c := a2 doInContext(call sender, call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"				if(getSlot(\"c\"), return getSlot(\"v\"))\n"
  	"			)\n"
  	"			return nil\n"
  	"		)\n"
  	"\n"
  	"		self foreach(v,\n"
  	"			ss := stopStatus(c := a1 doInContext(getSlot(\"v\"), call sender))\n"
  	"			if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"			if(ss stopLooping, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			if(getSlot(\"c\"), return getSlot(\"v\"))\n"
  	"		)\n"
  	"		nil\n"
  	"	)\n"
  	"\n"
  	"	map := method(\n"
  	"		aList := List clone\n"
  	"\n"
  	"		a1 := call argAt(0)\n"
  	"		if(a1 == nil, Exception raise(\"missing argument\"))\n"
  	"		a2 := call argAt(1)\n"
  	"		a3 := call argAt(2)\n"
  	"\n"
  	"		if(a2 == nil,\n"
  	"			self foreach(v,\n"
  	"				ss := stopStatus(c := a1 doInContext(getSlot(\"v\"), call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"				aList append(getSlot(\"c\"))\n"
  	"			)\n"
  	"			return aList\n"
  	"		)\n"
  	"\n"
  	"		if(a3 == nil,\n"
  	"			a1 := a1 name\n"
  	"			self foreach(v,\n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				ss := stopStatus(c := a2 doInContext(call sender, call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"				aList append(getSlot(\"c\"))\n"
  	"			)\n"
  	"			return aList\n"
  	"		)\n"
  	"\n"
  	"		a1 := a1 name\n"
  	"		a2 := a2 name\n"
  	"		self foreach(i, v,\n"
  	"			call sender setSlot(a1, i)\n"
  	"			call sender setSlot(a2, getSlot(\"v\"))\n"
  	"			ss := stopStatus(c := a3 doInContext(call sender, call sender))\n"
  	"			if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"			if(ss stopLooping, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			aList append(getSlot(\"c\"))\n"
  	"		)\n"
  	"		return aList\n"
  	"	)\n"
  	"\n"
  	"	groupBy := method(\n"
  	"		aMap := Map clone\n"
  	"\n"
  	"		a1 := call argAt(0)\n"
  	"		if(a1 == nil, Exception raise(\"missing argument\"))\n"
  	"		a2 := call argAt(1)\n"
  	"		a3 := call argAt(2)\n"
  	"\n"
  	"		if(a2 == nil,\n"
  	"			self foreach(v,\n"
  	"				ss := stopStatus(c := a1 doInContext(getSlot(\"v\"), call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"\n"
  	"				key := getSlot(\"c\") asString\n"
  	"\n"
  	"				aMap atIfAbsentPut(key, list())\n"
  	"				aMap at(key) append(v)\n"
  	"			)\n"
  	"			return aMap\n"
  	"		)\n"
  	"\n"
  	"		if(a3 == nil,\n"
  	"			a1 := a1 name\n"
  	"			self foreach(v,\n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				ss := stopStatus(c := a2 doInContext(call sender, call sender))\n"
  	"				if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"				if(ss stopLooping, break)\n"
  	"				if(ss isContinue, continue)\n"
  	"\n"
  	"				key := getSlot(\"c\") asString\n"
  	"\n"
  	"				aMap atIfAbsentPut(key, list())\n"
  	"				aMap at(key) append(v)\n"
  	"			)\n"
  	"			return aMap\n"
  	"		)\n"
  	"\n"
  	"		a1 := a1 name\n"
  	"		a2 := a2 name\n"
  	"		self foreach(i, v,\n"
  	"			call sender setSlot(a1, i)\n"
  	"			call sender setSlot(a2, getSlot(\"v\"))\n"
  	"			ss := stopStatus(c := a3 doInContext(call sender, call sender))\n"
  	"			if(ss isReturn, ss return getSlot(\"c\"))\n"
  	"			if(ss stopLooping, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"\n"
  	"			key := getSlot(\"c\") asString\n"
  	"\n"
  	"			aMap atIfAbsentPut(key, list())\n"
  	"			aMap at(key) append(v)\n"
  	"		)\n"
  	"		return aMap\n"
  	"	)\n"
  	"\n"
  	"  //doc List copy(v) Replaces self with <tt>v</tt> list items. Returns self. \n"
  	"	copy := method(v, self empty; self appendSeq(v); self)\n"
  	"\n"
  	"  //doc List mapInPlace Same as <tt>map</tt>, but result replaces self.\n"
  	"	mapInPlace := method(\n"
  	"		self copy(self getSlot(\"map\") performOn(self, call sender, call message))\n"
  	"	)\n"
  	"\n"
  	"  //doc List selectInPlace Same as <tt>select</tt>, but result replaces self.\n"
  	"	selectInPlace := method(\n"
  	"		self copy(self getSlot(\"select\") performOn(self, call sender, call message))\n"
  	"	)\n"
  	"\n"
  	"	empty := method(self removeAll)\n"
  	"\n"
  	"	isEmpty := method(size == 0)\n"
  	"	isNotEmpty := method(size > 0)\n"
  	"\n"
  	"	//doc List reverse Reverses the ordering of all the items of the receiver. Returns copy of receiver.\n"
  	"	reverse := method(itemCopy reverseInPlace)\n"
  	"\n"
  	"	//doc List itemCopy Returns a new list containing the items from the receiver.\n"
  	"	itemCopy := method(List clone copy(self))\n"
  	"\n"
  	"	sort := method(self clone sortInPlace)\n"
  	"	sortBy := method(b, self clone sortInPlaceBy(getSlot(\"b\")))\n"
  	"	/*\n"
  	"	print := method(\n"
  	"		e := try(\n"
  	"			s := Sequence clone\n"
  	"			s appendSeq(\"list(\")\n"
  	"			self foreach(i, v,\n"
  	"				if(i != 0, s appendSeq(\", \"))\n"
  	"				s appendSeq(getSlot(\"v\") asString)\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		if(e,\n"
  	"			s := Sequence clone\n"
  	"			s appendSeq(\"list(\")\n"
  	"			self foreach(i, v,\n"
  	"				if(i != 0, s appendSeq(\", \"))\n"
  	"				vs := \"[exception]\"\n"
  	"				try(vs := getSlot(\"v\") asString)\n"
  	"				s appendSeq(vs)\n"
  	"			)\n"
  	"\n"
  	"		)\n"
  	"		s appendSeq(\")\")\n"
  	"		s print\n"
  	"		self\n"
  	"	)\n"
  	"	*/\n"
  	"  //doc List second Returns second element (same as <tt>at(1)</tt>)\n"
  	"	second := method(at(1))\n"
  	"	//doc List second Returns third element (same as <tt>at(2)</tt>)\n"
  	"	third := method(at(2))\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "A0_List.io");

	s = "OperatorTable do(\n"
  	"	addOperator := method(symbol, precedence,\n"
  	"		precedence = precedence ifNilEval(0)\n"
  	"		operators atPut(symbol, precedence)\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	addAssignOperator := method(symbol, messageName,\n"
  	"		assignOperators atPut(symbol, messageName)\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	asString := method(\n"
  	"		s := Sequence clone appendSeq(OperatorTable asSimpleString, \":\\n\")\n"
  	"\n"
  	"		s appendSeq(\"Operators\")\n"
  	"		OperatorTable operators values unique sort foreach(precedence,\n"
  	"			s appendSeq(\"\\n  \", precedence asString alignLeft(4), OperatorTable operators select(k, v, v == precedence) keys sort join(\" \"))\n"
  	"		)\n"
  	"\n"
  	"		s appendSeq(\"\\n\\nAssign Operators\")\n"
  	"		OperatorTable assignOperators keys sort foreach(symbol,\n"
  	"			name := OperatorTable assignOperators at(symbol)\n"
  	"			s appendSeq(\"\\n  \", symbol alignLeft(4), name)\n"
  	"		)\n"
  	"\n"
  	"		s appendSeq(\"\\n\\n\")\n"
  	"		s appendSeq(\"To add a new operator: OperatorTable addOperator(\\\"+\\\", 4) and implement the + message.\\n\")\n"
  	"		s appendSeq(\"To add a new assign operator: OperatorTable addAssignOperator(\\\"=\\\", \\\"updateSlot\\\") and implement the updateSlot message.\\n\")\n"
  	"\n"
  	"		s\n"
  	"	)\n"
  	"\n"
  	"	reverseAssignOperators := method(assignOperators reverseMap)\n"
  	")\n"
  	"\n"
  	"# Make the lookup path shorter for the opShuffle. IoMessage_opShuffle looks up\n"
  	"# the OperatorTable object on the first message before starting shuffling.\n"
  	"Message OperatorTable := OperatorTable\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "A1_OperatorTable.io");

	s = "/*\n"
  	"//metadoc nil description nil is a singleton object that is used as a placeholder and to mean false in Io.\")\n"
  	"\n"
  	"nil do(\n"
  	"	//doc nil clone returns self since nil is a singleton.\n"
  	"	clone := nil\n"
  	"\n"
  	"	//doc nil and(expression) Returns nil without evaluating expression.\n"
  	"	setSlot(\"and\", nil)\n"
  	"\n"
  	"	elseif := Object getSlot(\"if\")\n"
  	"\n"
  	"	//doc nil then(expression) Returns nil without evaluating expression.\n"
  	"	setSlot(\"then\", nil)\n"
  	"\n"
  	"	//doc nil else(expression) Returns nil without evaluating expression.\n"
  	"	setSlot(\"else\", method(v, v))\n"
  	"\n"
  	"	//doc nil or(anObject) Returns anObject if anObject is not nil. Otherwise returns nil.\n"
  	"	setSlot(\"or\", method(v, if(v, v, nil)))\n"
  	"\n"
  	"	//doc nil print Prints 'nil'. Returns self.\n"
  	"	print := method(write(\"nil\"))\n"
  	"\n"
  	"	setSlot(\"==\", method(v, self isIdenticalTo(v)))\n"
  	"	setSlot(\"!=\", method(v, self isIdenticalTo(v) not))\n"
  	"\n"
  	"	//doc nil isNil Returns Lobby.\n"
  	"	isNil := Lobby\n"
  	"\n"
  	"	//doc nil ifNil(expression) Evaluates message.\n"
  	"	ifNil := method(v, v)\n"
  	")\n"
  	"*/\n"
  	"\n"
  	"// if(a == 1) then(b) elseif(b == c) then(d) else(f)\n"
  	"// (a == 1) ifTrue(b) ifFalse(c)\n"
  	"\n"
  	"true do(\n"
  	"	//doc true then Evaluates the argument and returns nil.\n"
  	"	then    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"\n"
  	"	//doc true elseif Does not eval argument and returns true.\n"
  	"	elseif  := true\n"
  	"\n"
  	"	//doc true else Does not eval argument and returns true.\n"
  	"	else    := true\n"
  	"\n"
  	"	//doc true ifTrue Evaluates the argument and returns self.\n"
  	"	ifTrue  := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	\n"
  	"	//doc true ifFalse Does not eval argument and returns true.\n"
  	"	ifFalse := true\n"
  	"	\n"
  	"	//doc true and Evaluates the argument and returns the result.\n"
  	"	\n"
  	"	//doc true or Does not eval argument and returns true.\n"
  	"	setSlot(\"or\", true)\n"
  	"\n"
  	"	//doc true asString Returns true.\n"
  	"	asString := \"true\"\n"
  	"\n"
  	"	//doc true asSimpleString Returns true.\n"
  	"	asSimpleString := \"true\"\n"
  	"\n"
  	"	//doc true not Does not eval argument and returns false.\n"
  	"	not := false\n"
  	"	\n"
  	"	//doc true clone Returns true.\n"
  	"	clone := true\n"
  	")\n"
  	"\n"
  	"false do(\n"
  	"  //doc false then Returns false.\n"
  	"	then    := false\n"
  	"	//doc false ifTrue Returns false.\n"
  	"	ifTrue  := false\n"
  	"	//doc false ifFalse Evaluates the argument and returns self.\n"
  	"	ifFalse := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	//doc false elseif Same as <tt>if</tt>.\n"
  	"	elseif  := Object getSlot(\"if\")\n"
  	"	//doc false else Evaluates the argument and returns nil.\n"
  	"	else    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"	//doc false and Returns false.\n"
  	"	setSlot(\"and\", false)\n"
  	"	//doc false or Evaluates the argument and returns the result.\n"
  	"	or := method(v, v isTrue)\n"
  	"  \n"
  	"  //doc false type Returns \"false\".\n"
  	"	type := \"false\"\n"
  	"	//doc false asString Returns \"false\".\n"
  	"	asString := \"false\"\n"
  	"	//doc false asSimpleString Returns \"false\".\n"
  	"	asSimpleString := \"false\"\n"
  	"	//doc false not Returns true.\n"
  	"	not := true\n"
  	"	//doc false clone Returns self.\n"
  	"	clone := false\n"
  	"	isTrue := false\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"	not := true\n"
  	"	isNil := true\n"
  	"\n"
  	"	ifNonNil := Object getSlot(\"thisContext\")\n"
  	"	ifNil := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"\n"
  	"	ifNilEval    := Object getSlot(\"evalArg\")\n"
  	"	ifNonNilEval := Object getSlot(\"thisContext\")\n"
  	"\n"
  	"	type := \"nil\"\n"
  	"	asString := type\n"
  	"	asSimpleString := type\n"
  	"\n"
  	"	setSlot(\"and\", false)\n"
  	"	or := method(v, v isTrue)\n"
  	"	then := nil\n"
  	"	else := nil\n"
  	"	elseif := nil\n"
  	"	clone := nil\n"
  	"	isTrue := false\n"
  	")\n"
  	"\n"
  	"// I think non-local returns can eliminate all this stopStatus stuff \n"
  	"\n"
  	"Call do(\n"
  	"  /*doc Call relayStopStatus(arg) \n"
  	"  Sets sender's stop status (Normal, Return, \n"
  	"  Break, Continue etc.) and returns evaluated argument.\n"
  	"  */\n"
  	"	relayStopStatus := method(\n"
  	"		ss := stopStatus(r := call evalArgAt(0))\n"
  	"		call sender call setStopStatus(ss)\n"
  	"		getSlot(\"r\")\n"
  	"	)\n"
  	"\n"
  	"  /*doc Call resetStopStatus(arg) \n"
  	"  Sets stop status to Normal.\n"
  	"  See also <tt>Call setStopStatus</tt>.\n"
  	"  */\n"
  	"	resetStopStatus := method(\n"
  	"		setStopStatus(Normal)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Normal do(\n"
  	"	stopLooping := false\n"
  	"	isReturn := false\n"
  	"	isBreak := false\n"
  	"	isContinue := false\n"
  	"\n"
  	"	return := method(arg,\n"
  	"		call setStopStatus(Return)\n"
  	"		getSlot(\"arg\")\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Eol appendProto(Normal)\n"
  	"Continue appendProto(Normal) do(\n"
  	"	isContinue := true\n"
  	")\n"
  	"\n"
  	"Break appendProto(Normal) do(\n"
  	"	stopLooping := true\n"
  	"	isBreak := true\n"
  	")\n"
  	"\n"
  	"Return appendProto(Normal) do(\n"
  	"	stopLooping := true\n"
  	"	isReturn := true\n"
  	"\n"
  	"	return := method(arg,\n"
  	"		call setStopStatus(Return)\n"
  	"		call sender call setStopStatus(Return)\n"
  	"		getSlot(\"arg\")\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	//doc Object not Returns nil.\n"
  	"	not := nil\n"
  	"	//doc Object isNil Returns false.\n"
  	"	isNil := false\n"
  	"	//doc Object ifNil(arg) Does nothing, returns self.\n"
  	"	ifNil := Object getSlot(\"thisContext\")\n"
  	"	//doc Object ifNonNil(arg) Evaluates argument and returns self.\n"
  	"	ifNonNil := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	//doc Object ifNonNilEval(arg) Evaluates argument and returns the result.\n"
  	"	ifNonNilEval := Object getSlot(\"evalArg\")\n"
  	"	//doc Object ifNilEval(arg) Does nothing, returns self.\n"
  	"	ifNilEval    := Object getSlot(\"thisContext\")\n"
  	"	//doc Object or(arg) Returns true.\n"
  	"	setSlot(\"or\", true)\n"
  	"	\n"
  	"	//doc Object isTrue Returns true.\n"
  	"	isTrue := true\n"
  	"	//doc Object and(arg) Evaluates argument and returns the result.\n"
  	"	and := method(v, v isTrue)\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"  /*doc Sequence makeFirstCharacterLowercase \n"
  	"  Receiver must be mutable (see also asMutable). Returns receiver.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> \"ABC\" asMutable makeFirstCharacterLowercase\n"
  	"  ==> aBC\n"
  	"  </pre>\n"
  	"  */\n"
  	"	makeFirstCharacterLowercase := method(\n"
  	"		if(self size > 0, self atPut(0, self at(0) asLowercase))\n"
  	"	)\n"
  	"  /*doc Sequence makeFirstCharacterUppercase \n"
  	"  Receiver must be mutable (see also asMutable). Returns receiver.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> \"abc\" asMutable makeFirstCharacterUppercase\n"
  	"  ==> Abc\n"
  	"  </pre>\n"
  	"  */\n"
  	"	makeFirstCharacterUppercase := method(\n"
  	"		if(self size > 0, self atPut(0, self at(0) asUppercase))\n"
  	"	)\n"
  	"\n"
  	"  /*doc Sequence slicesBetween(startSeq, endSeq) \n"
  	"  Returns a list of slices delimited \n"
  	"  by <tt>startSeq</tt> and <tt>endSeq</tt>.\n"
  	"  <br>\n"
  	"  <pre>\n"
  	"  Io> \"<a><b></b></a>\" slicesBetween(\"<\", \">\")\n"
  	"  ==> list(\"a\", \"b\", \"/b\", \"/a\")\n"
  	"  </pre>\n"
  	"  */\n"
  	"	slicesBetween := method(startSeq, endSeq,\n"
  	"		chunks := List clone\n"
  	"		lastIndex := 0\n"
  	"		while (startIndex := self findSeq(startSeq, lastIndex),\n"
  	"			endIndex := self findSeq(endSeq, startIndex + startSeq size)\n"
  	"			endIndex ifNil(break)\n"
  	"			chunks append(self exclusiveSlice(startIndex + startSeq size, endIndex))\n"
  	"			lastIndex := endIndex + endSeq size\n"
  	"		)\n"
  	"		chunks\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"  /*doc Object hasSlot(name) \n"
  	"  Returns <tt>true</tt> if slot is found somewhere in the inheritance chain \n"
  	"  (including receiver itself).\n"
  	"  */\n"
  	"	hasSlot := method(n,\n"
  	"		getSlot(\"self\") hasLocalSlot(n) or(getSlot(\"self\") ancestorWithSlot(n) != nil)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object list(...) Returns a List containing the arguments.\n"
  	"	list := method(call message argsEvaluatedIn(call sender))\n"
  	"\n"
  	"	//doc Object ..(arg) .. is an alias for: method(arg, self asString append(arg asString))\n"
  	"	setSlot(\"..\", method(arg, getSlot(\"self\") asString .. arg asString))\n"
  	"\n"
  	"	Map addKeysAndValues := method(keys, values, keys foreach(i, k, self atPut(k, values at(i))); self)\n"
  	"  \n"
  	"  /*doc Object slotDescriptionMap\n"
  	"  Returns raw map of slot names and short values' descriptions.\n"
  	"  See also <tt>Object slotSummary</tt>.\n"
  	"  */\n"
  	"	slotDescriptionMap := method(\n"
  	"		slotNames := getSlot(\"self\") slotNames sort\n"
  	"		slotDescs := slotNames map(name, getSlot(\"self\") getSlot(name) asSimpleString)\n"
  	"		Map clone addKeysAndValues(slotNames, slotDescs)\n"
  	"	)\n"
  	"  //doc Object apropos Prints out <tt>Protos Core</tt> slot descriptions.\n"
  	"	apropos := method(keyword,\n"
  	"		Protos Core foreachSlot(name, p,\n"
  	"			slotDescriptions := getSlot(\"p\") slotDescriptionMap ?select(k, v, k asMutable lowercase containsSeq(keyword))\n"
  	"\n"
  	"			if(slotDescriptions and slotDescriptions size > 0,\n"
  	"				s := Sequence clone\n"
  	"				slotDescriptions keys sortInPlace foreach(k,\n"
  	"					s appendSeq(\"  \", k alignLeft(16), \" = \", slotDescriptions at(k), \"\\n\")\n"
  	"				)\n"
  	"\n"
  	"				writeln(name)\n"
  	"				writeln(s)\n"
  	"			)\n"
  	"		)\n"
  	"		nil\n"
  	"	)\n"
  	"  /*doc Object slotSummary \n"
  	"  Returns a formatted <tt>slotDescriptionMap</tt>.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> slotSummary\n"
  	"  ==>  Object_0x30c590:\n"
  	"    Lobby            = Object_0x30c590\n"
  	"    Protos           = Object_0x30c880\n"
  	"    exit             = method(...)\n"
  	"    forward          = method(...)\n"
  	"  </pre>\n"
  	"  */\n"
  	"  \n"
  	"	slotSummary := method(keyword,\n"
  	"		if(getSlot(\"self\") type == \"Block\",\n"
  	"			return getSlot(\"self\") asSimpleString\n"
  	"		)\n"
  	"		\n"
  	"		s := Sequence clone\n"
  	"		s appendSeq(\" \", getSlot(\"self\") asSimpleString, \":\\n\")\n"
  	"		slotDescriptions := slotDescriptionMap\n"
  	"		\n"
  	"		if(keyword,\n"
  	"			slotDescriptions = slotDescriptions select(k, v, k asMutable lowercase containsSeq(keyword))\n"
  	"		)\n"
  	"		\n"
  	"		slotDescriptions keys sortInPlace foreach(k,\n"
  	"			s appendSeq(\"  \", k alignLeft(16), \" = \", slotDescriptions at(k), \"\\n\")\n"
  	"		)\n"
  	"		s\n"
  	"	)\n"
  	"  \n"
  	"  //doc Object asString Same as <tt>slotSummary</tt>.\n"
  	"	asString := getSlot(\"slotSummary\")\n"
  	"\n"
  	"  //doc Object asSimpleString Returns <type>_<uniqueHexId> string.\n"
  	"	asSimpleString := method(getSlot(\"self\") type .. \"_\" .. getSlot(\"self\") uniqueHexId)\n"
  	"\n"
  	"	/*doc Object newSlot(slotName, aValue)\n"
  	"	Creates a getter and setter for the slot with the name slotName\n"
  	"	and sets it's default the value aValue. Returns self. For example,\n"
  	"	newSlot(\"foo\", 1) would create slot named foo with the value 1 as well as a setter method setFoo().\n"
  	"	*/\n"
  	"\n"
  	"	newSlot := method(name, value, doc,\n"
  	"		getSlot(\"self\") setSlot(name, getSlot(\"value\"))\n"
  	"		getSlot(\"self\") setSlot(\"set\" .. name asCapitalized,\n"
  	"			doString(\"method(\" .. name .. \" = call evalArgAt(0); self)\"))\n"
  	"			//if(doc, getSlot(\"self\") docSlot(name, doc))\n"
  	"		getSlot(\"value\")\n"
  	"	)\n"
  	"\n"
  	"	//doc Object launchFile(pathString) Eval file at pathString as if from the command line in it's folder.\n"
  	"  //doc System launchPath Returns a pathComponent of the launch file.\n"
  	"	launchFile := method(path, args,\n"
  	"		args ifNil(args = List clone)\n"
  	"		System launchPath :=  path pathComponent\n"
  	"		Directory setCurrentWorkingDirectory(System launchPath)\n"
  	"		System launchScript = path\n"
  	"		self doFile(path)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object println Same as print, but also prints a new line. Returns self.\n"
  	"	println := method(getSlot(\"self\") print; write(\"\\n\"); self)\n"
  	"\n"
  	"	/*doc Object ?(aMessage)\n"
  	"	description: Sends the message aMessage to the receiver if it can respond to it. Example:\n"
  	"	<pre>\n"
  	"	MyObject test // performs test\n"
  	"	MyObject ?test // performs test if MyObject has a slot named test\n"
  	"	</pre>\n"
  	"	The search for the slot only follows the receivers proto chain.\n"
  	"	*/\n"
  	"\n"
  	"	setSlot(\"?\",\n"
  	"		method(\n"
  	"			m := call argAt(0)\n"
  	"			if (self getSlot(m name) != nil,\n"
  	"				call relayStopStatus(m doInContext(self, call sender))\n"
  	"			,\n"
  	"				nil\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object ancestors Returns a list of all of the receiver's ancestors as found by recursively following the protos links.\n"
  	"\n"
  	"	ancestors := method(a,\n"
  	"		if(a, if(a detect(x, x isIdenticalTo(self)), return a), a = List clone)\n"
  	"		a append(self)\n"
  	"		self protos foreach(ancestors(a))\n"
  	"		a\n"
  	"	)\n"
  	"\n"
  	"	//doc Object isKindOf(anObject) Returns true if anObject is in the receiver's ancestors.\n"
  	"\n"
  	"	isKindOf := method(anObject, getSlot(\"self\") ancestors contains(getSlot(\"anObject\")))\n"
  	"\n"
  	"	/*doc Object super(aMessage)\n"
  	"	Sends the message aMessage to the receiver's proto with the context of self. Example:\n"
  	"	<pre>\n"
  	"	self test(1, 2)   // performs test(1, 2) on self\n"
  	"	super(test(1, 2)) // performs test(1, 2) on self proto but with the context of self\n"
  	"	</pre>\n"
  	"	*/\n"
  	"\n"
  	"	setSlot(\"super\", method(\n"
  	"		senderSlotContext := call sender call slotContext\n"
  	"		m := call argAt(0)\n"
  	"		m ifNil(Exception raise(\"Object super requires an argument\"))\n"
  	"		senderSlotContext ifNil(Exception raise(\"Object super called outside of block context\"))\n"
  	"		slotName := m name\n"
  	"		ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"		if(ancestor == nil,\n"
  	"			slotName = \"forward\"\n"
  	"			ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"		)\n"
  	"		if(ancestor isIdenticalTo(senderSlotContext), Exception raise(\"Object super slot \" .. slotName .. \" not found\"))\n"
  	"		b := ancestor getSlot(slotName)\n"
  	"		if(getSlot(\"b\") isActivatable == false,\n"
  	"			b\n"
  	"		,\n"
  	"			getSlot(\"b\") performOn(call sender call target, call sender, m, ancestor)\n"
  	"		)\n"
  	"	))\n"
  	"\n"
  	"	/*doc Object resend\n"
  	"	Send the message used to activate the current method to the Object's proto.\n"
  	"  For example:\n"
  	"  <pre>\n"
  	"  Dog := Mammal clone do(\n"
  	"    init := method(\n"
  	"  	  resend\n"
  	"    )\n"
  	"  )\n"
  	"  </pre>\n"
  	"	Calling Dog init will send an init method to Mammal, but using the Dog's context.\n"
  	"	*/\n"
  	"\n"
  	"	setSlot(\"resend\", method(\n"
  	"		senderSlotContext := call sender call slotContext\n"
  	"		senderSlotContext ifNil(Exception raise(\"Object resend called outside of block context\"))\n"
  	"		m := call sender call message\n"
  	"		slotName := m name\n"
  	"		ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"\n"
  	"		if(ancestor isIdenticalTo(nil),\n"
  	"			slotName = \"forward\"\n"
  	"			ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"		)\n"
  	"\n"
  	"		if(ancestor isIdenticalTo(senderSlotContext),\n"
  	"			Exception raise(\"Object resend slot \" .. slotName .. \" not found\")\n"
  	"		)\n"
  	"\n"
  	"		b := ancestor getSlot(slotName)\n"
  	"		if(getSlot(\"b\") != nil,\n"
  	"			getSlot(\"b\") performOn(call sender getSlot(\"self\"), call sender call sender, m, ancestor)\n"
  	"		,\n"
  	"			getSlot(\"b\")\n"
  	"		)\n"
  	"	))\n"
  	"\n"
  	"\n"
  	"	//doc Object list(...) Returns a List containing the arguments.\n"
  	"	list := method(call message argsEvaluatedIn(call sender))\n"
  	"\n"
  	"	Object print := method(write(getSlot(\"self\") asString); getSlot(\"self\"))\n"
  	"\n"
  	"	//doc Object println Same as print, but also prints a new line. Returns self.\n"
  	"	println := method(getSlot(\"self\") print; write(\"\\n\"); getSlot(\"self\"))\n"
  	"\n"
  	"	//doc Object in(aList) Same as: aList contains(self)\n"
  	"	in := method(aList, aList contains(self))\n"
  	"\n"
  	"  /*doc Object uniqueHexId \n"
  	"  Returns uniqueId in a hexadecimal form (with a \"0x\" prefix)\n"
  	"  <pre>\n"
  	"  Io> Object uniqueId\n"
  	"  ==> 3146784\n"
  	"  Io> Object uniqueHexId\n"
  	"  ==> 0x300420\n"
  	"  </pre>\n"
  	"  */\n"
  	"	uniqueHexId := method(\"0x\" .. getSlot(\"self\") uniqueId asString toBase(16))\n"
  	"\n"
  	"  /*doc Object lazySlot(code) \n"
  	"  Defines a slot with a lazy initialization code. \n"
  	"  Code is run only once: the first time slot is accessed. \n"
  	"  Returned value is stored in a regular slot.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> x := lazySlot(\"Evaluated!\" println; 17)\n"
  	"  Io> x\n"
  	"  Evaluated!\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  </pre>\n"
  	"  <br/>\n"
  	"  Another form is <tt>lazySlot(name, code)</tt>:\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> lazySlot(\"x\", \"Evaluated!\" println; 17)\n"
  	"  Io> x\n"
  	"  Evaluated!\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  </pre>\n"
  	"  */\n"
  	"	lazySlot := method(\n"
  	"		if(call argCount == 1,\n"
  	"			m := method(\n"
  	"				self setSlot(call message name, nil)\n"
  	"			)\n"
  	"\n"
  	"			args := getSlot(\"m\") message next arguments\n"
  	"			args atPut(1, call argAt(0) clone)\n"
  	"			getSlot(\"m\") message next setArguments(args)\n"
  	"\n"
  	"			getSlot(\"m\") clone\n"
  	"		,\n"
  	"			name := call evalArgAt(0)\n"
  	"			m := (\"self setSlot(\\\"\" .. name .. \"\\\", \" .. call argAt(1) code .. \")\") asMessage\n"
  	"			self setSlot(name, method() setMessage(m))\n"
  	"			nil\n"
  	"		)\n"
  	"	)\n"
  	"  \n"
  	"  /*doc Object foreachSlot(slotName, slotValue, code)\n"
  	"  Iterates over all the slots in a receiver. Provides slotValue (non-activated)\n"
  	"  along with slotName. Code is executed in context of sender. <tt>slotName</tt> and <tt>slotValue</tt>\n"
  	"  become visible in the receiver (no Locals created! Maybe, it is not the best decision).\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> thisContext foreachSlot(n, v, n println)\n"
  	"  Lobby\n"
  	"  Protos\n"
  	"  exit\n"
  	"  forward\n"
  	"  n\n"
  	"  v\n"
  	"  ==> false\n"
  	"  </pre>\n"
  	"  */\n"
  	"	foreachSlot := method(\n"
  	"		self slotNames sort foreach(n,\n"
  	"			call sender setSlot(call message argAt(0) name, n)\n"
  	"			call sender setSlot(call message argAt(1) name, getSlot(\"self\") getSlot(n))\n"
  	"			r := call relayStopStatus(call evalArgAt(2))\n"
  	"			if(call stopStatus isReturn, return getSlot(\"r\"))\n"
  	"			if(call stopStatus stopLooping,\n"
  	"				call resetStopStatus\n"
  	"				break\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	/*doc Object switch(<key1>, <expression1>, <key2>, <expression2>, ...) \n"
  	"	Execute an expression depending on the value of the caller. (This is an equivalent to C switch/case)\n"
  	"	<code>\n"
  	"	hour := Date hour switch(\n"
  	"		12, \"midday\",\n"
  	"		0, \"midnight\",\n"
  	"		17, \"teatime\",\n"
  	"		Date hour asString\n"
  	"	)\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	switch := method(\n"
  	"		for(couple, 0, call argCount - 2, 2,\n"
  	"			if(call evalArgAt(couple) == self,\n"
  	"				return call relayStopStatus(call evalArgAt(couple + 1))\n"
  	"			)\n"
  	"		)\n"
  	"		if(call argCount isOdd,\n"
  	"			call relayStopStatus(call evalArgAt(call argCount - 1))\n"
  	"		,\n"
  	"			nil\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object isLaunchScript Returns true if the current file was run on the command line. Io's version of Python's __file__ == \"__main__\"\n"
  	"	isLaunchScript := method(\n"
  	"		call message label == System launchScript\n"
  	"	)\n"
  	"\n"
  	"	/*doc Object doRelativeFile(pathString)\n"
  	"		Evaluates the File in the context of the receiver. Returns the result. \n"
  	"		pathString is relative to the file calling doRelativeFile. (Duplicate of relativeDoFile)\n"
  	"	*/\n"
  	"	doRelativeFile := method(path,\n"
  	"		self doFile(Path with(call message label pathComponent, path))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Object relativeDoFile(pathString)\n"
  	"		Evaluates the File in the context of the receiver. Returns the result. \n"
  	"		pathString is relative to the file calling doRelativeFile. (Duplicate of doRelativeFile)\n"
  	"	*/\n"
  	"	relativeDoFile := getSlot(\"doRelativeFile\")\n"
  	"	\n"
  	"	/*doc Object deprecatedWarning(optionalNewName) \n"
  	"	Prints a warning message that the current method is deprecated.\n"
  	"	If optionalNewName is supplied, the warning will suggest using that instead.\n"
  	"	Returns self.\n"
  	"	*/\n"
  	"	Object deprecatedWarning := method(newName,\n"
  	"		writeln(\"Warning in \", call sender call message label, \": '\", call sender call message name, \"' is deprecated\", if(newName, \".  Use '\" .. newName .. \"' instead.\", \" and will be removed from a later version.\"))\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	//referenceIdForObject := method(obj, getSlot(\"obj\") unqiueId)\n"
  	"	//objectForReferenceId := method(id, Collector objectWithUniqueId(id))\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "A2_Object.io");

	s = "\n"
  	"List do(\n"
  	"	//doc List sum Returns the sum of the items.\n"
  	"	sum := method(s := 0; self foreach(v, s = s + v); s)\n"
  	"\n"
  	"	//doc List average Returns the average of the items.\n"
  	"	average := method(self sum / self size)\n"
  	"\n"
  	"	//doc List shuffleInPlace Randomizes the order of the elements in the receiver. Returns self.\n"
  	"	shuffleInPlace := method(for(i, 0, size - 1, swapIndices(i, Random value(i, size) floor)))\n"
  	"	\n"
  	"	//doc List shuffle Randomizes the ordering of all the items of the receiver. Returns copy of receiver.\n"
  	"	shuffle := method(self itemCopy shuffleInPlace)\n"
  	"\n"
  	"	//doc List anyOne Returns a random element of the receiver or nil if the receiver is empty.\n"
  	"	anyOne := method(at(Random value(0, size) floor))\n"
  	"\n"
  	"	//doc List removeFirst Returns the first item and removes it from the list. nil is returned if the list is empty.\n"
  	"	removeFirst := method(if(self size != 0, removeAt(0), nil))\n"
  	"\n"
  	"	//doc List removeLast Returns the last item and removes it from the list. nil is returned if the list is empty.\n"
  	"	removeLast := method(self pop)\n"
  	"\n"
  	"	//doc List removeSeq Removes each of the items from the current list which are contained in the sequence passed in.\n"
  	"	removeSeq := method(seq,\n"
  	"		seq foreach(x, self remove(x))\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	//doc List rest Returns a copy of the list but with the first element removed.\n"
  	"	rest := method(slice(1))\n"
  	"\n"
  	"	/*doc List join(optionalString) \n"
  	"		Returns a Sequence of the concatenated items with \n"
  	"		optionalString between each item or simply the concatenation of the items if no optionalString is supplied.\n"
  	"	*/\n"
  	"		\n"
  	"	join := method(arg,\n"
  	"		s := if(self first type == \"List\", \n"
  	"			List clone\n"
  	"		, \n"
  	"			Sequence clone \n"
  	"		)\n"
  	"\n"
  	"		if(arg,\n"
  	"			max := self size - 1\n"
  	"			self foreach(i, v, s appendSeq(v); if(i != max, s appendSeq(arg)))\n"
  	"		,\n"
  	"			self foreach(v, s appendSeq(v))\n"
  	"		)\n"
  	"\n"
  	"		s\n"
  	"	)\n"
  	"\n"
  	"	/*doc List insertAfter(item, afterItem) \n"
  	"	Inserts item after first occurance of afterItem and returns self. \n"
  	"	If afterItem is not found, item is appended to the end of the list.\n"
  	"	*/\n"
  	"	insertAfter := method(item, afterItem,\n"
  	"		i := self indexOf(afterItem)\n"
  	"		if(i, self atInsert(i + 1, item), self append(item))\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	//doc List insertBefore(item, beforeItem) Inserts item before first occurance of beforeItem or to the end of the list if beforeItem is not found. Returns self.\n"
  	"	insertBefore := method(item, beforeItem,\n"
  	"		i := self indexOf(beforeItem)\n"
  	"		if(i, self atInsert(i, item), self append(item))\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	//doc List insertAt(item, index) Inserts item at the specified index. Raises an exception if the index is out of bounds. Returns self.\n"
  	"	insertAt := method(item, index, self atInsert(index, item))\n"
  	"\n"
  	"	asString := method(\n"
  	"		s := \"list(\" asMutable\n"
  	"		self foreach(i, v,\n"
  	"			s appendSeq(getSlot(\"v\") asSimpleString)\n"
  	"			if (i != self size - 1, s appendSeq(\", \"))\n"
  	"		)\n"
  	"		s appendSeq(\")\")\n"
  	"	)\n"
  	"\n"
  	"	max := method(\n"
  	"		m := call argAt(0)\n"
  	"		obj := self first\n"
  	"		self foreach(o,\n"
  	"			v1 := if(m, o doMessage(m, call sender), o)\n"
  	"			v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"			if(v1 > v2, obj := o)\n"
  	"		)\n"
  	"		obj\n"
  	"	)\n"
  	"\n"
  	"	min := method(\n"
  	"		m := call argAt(0)\n"
  	"		obj := self first\n"
  	"		self foreach(o,\n"
  	"			v1 := if(m, o doMessage(m, call sender), o)\n"
  	"			v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"			if(v1 < v2, obj := o)\n"
  	"		)\n"
  	"		obj\n"
  	"	)\n"
  	"\n"
  	"	/*doc List flatten \n"
  	"	Creates a new list, with all contained lists flattened into the new list. For example:\n"
  	"<code>\n"
  	"list(1,2,list(3,4,list(5))) flatten\n"
  	"==> list(1, 2, 3, 4, 5)\n"
  	"</code>\n"
  	"	*/\n"
  	"	\n"
  	"	List flatten := method(\n"
  	"		l := List clone\n"
  	"		self foreach(v,\n"
  	"			if(getSlot(\"v\") type == \"List\",\n"
  	"				l appendSeq(getSlot(\"v\") flatten)\n"
  	"			,\n"
  	"				l append(getSlot(\"v\")))\n"
  	"		)\n"
  	"		l\n"
  	"	)\n"
  	"\n"
  	"	/*doc List asMessage Converts each element in the list to unnamed messages \n"
  	"	with their cached result set to the value of the element (without activating). \n"
  	"	Returns an unnamed message whose arguments map 1:1 with the elements (after being converted to messages themselves).\n"
  	"	*/\n"
  	"	\n"
  	"	asMessage := method(\n"
  	"		m := Message clone\n"
  	"		foreach(elem,\n"
  	"			m setArguments(\n"
  	"				m arguments append(Message clone setCachedResult(getSlot(\"elem\")))\n"
  	"			)\n"
  	"		)\n"
  	"		m\n"
  	"	)\n"
  	"\n"
  	"	/*doc List select(optionalIndex, value, message)\",\n"
  	"		\"Like foreach, but the values for which the result of\n"
  	"message are non-nil are returned in a new List. Example:\n"
  	"<code>list(1, 5, 7, 2) select(i, v, v > 3) print\n"
  	"==> 5, 7\n"
  	"\n"
  	"list(1, 5, 7, 2) select(v, v > 3) print\n"
  	"==> 5, 7</code>\n"
  	"*/\n"
  	"\n"
  	"	/*doc List detect(optionalIndex, value, message)\n"
  	"	Returns the first value for which the message evaluates to a non-nil. Example:\n"
  	"<code>list(1, 2, 3, 4) detect(i, v, v > 2)\n"
  	"==> 3\n"
  	"\n"
  	"list(1, 2, 3, 4) detect(v, v > 2)\n"
  	"==> 3</code>\n"
  	"*/\n"
  	"\n"
  	"	//doc List map(optionalIndex, value, message) Same as calling mapInPlace() on a clone of the receiver, but more efficient.\n"
  	"\n"
  	"	//doc List cursor Returns a ListCursor for the receiver.\n"
  	"	cursor := method(ListCursor clone setCollection(self))\n"
  	"\n"
  	"	//doc List containsAll(list) Returns true the target contains all of the items in the argument list.\n"
  	"	containsAll := method(c, c detect(i, contains(i) not) == nil)\n"
  	"\n"
  	"	//doc List containsAny(list) Returns true the target contains any of the items in the argument list.\n"
  	"	containsAny := method(c, c detect(i, contains(i)) != nil)\n"
  	"\n"
  	"	//doc List intersect(list) Returns a new list containing the common values from the target and argument lists.\n"
  	"	intersect := method(c, c select(i, contains(i)))\n"
  	"\n"
  	"	//doc List difference(list) Returns a new list containing items from the target list which aren't in the argument list.\n"
  	"	difference := method(c, select(i, c contains(i) not))\n"
  	"\n"
  	"	//doc List union(list) Returns a new list containing items from the target and items which are only in the argument list.\n"
  	"	union := method(c, self clone appendSeq(c difference(self)))\n"
  	"\n"
  	"	//doc List unique Returns a new list containing all the values in the target, but no duplicates.\n"
  	"	unique := method(a := list; self foreach(v, a appendIfAbsent(v)); a)\n"
  	"\n"
  	"	//doc List asMap The reverse of Map asList: converts a list of lists (key-value pairs) into a Map. The first item of each pair list must be a sequence. The second item is the value.\n"
  	"	asMap := method(\n"
  	"		m := Map clone\n"
  	"		self foreach(pair, m atPut(pair at(0), pair at(1)))\n"
  	"	)\n"
  	"\n"
  	"		//doc List reduce Also known as foldl or inject. Combines values in target start on the left. reduce(+) or reduce(x, y, x + y).\n"
  	"		reduce := method(\n"
  	"			accu := first\n"
  	"			if(call message arguments size == 1,\n"
  	"				args := list(nil)\n"
  	"				meth := call argAt(0) name\n"
  	"				exSlice(1) foreach(x, accu = accu performWithArgList(meth, args atPut(0, x)))\n"
  	"			,\n"
  	"				aName := call argAt(0) name\n"
  	"				bName := call argAt(1) name\n"
  	"				body := call argAt(2)\n"
  	"				exSlice(1) foreach(x,\n"
  	"					call sender setSlot(aName, accu)\n"
  	"					call sender setSlot(bName, x)\n"
  	"					accu = call sender doMessage(body, call sender)\n"
  	"				)\n"
  	"			)\n"
  	"			accu\n"
  	"		)\n"
  	"\n"
  	"		//doc List reverseReduce Also known as foldr and inject. Combines values in target starting on the right. reverseReduce(+) or reverseReduce(x, y, x + y).\n"
  	"		reverseReduce := method(\n"
  	"			accu := last\n"
  	"			if(call message arguments size == 1,\n"
  	"				args := list(nil)\n"
  	"				meth := call argAt(0) name\n"
  	"				exSlice(0, -1) reverseForeach(x, accu = x performWithArgList(meth, args atPut(0, accu)))\n"
  	"			,\n"
  	"				aName := call argAt(0) name\n"
  	"				bName := call argAt(1) name\n"
  	"				body := call argAt(2)\n"
  	"				exSlice(0, -1) reverseForeach(x,\n"
  	"					call sender setSlot(aName, x)\n"
  	"					call sender setSlot(bName, accu)\n"
  	"					accu = call sender doMessage(body, call sender)\n"
  	"				)\n"
  	"			)\n"
  	"			accu\n"
  	"		)\n"
  	"\n"
  	"\n"
  	"		mapFromKey := method(key,\n"
  	"			e := key asMessage\n"
  	"			m := Map clone\n"
  	"			self foreach(v,\n"
  	"				k := getSlot(\"v\") doMessage(e)\n"
  	"				l := m at(k)\n"
  	"				if(l, l append(getSlot(\"v\")), m atPut(k, list(getSlot(\"v\"))))\n"
  	"			)\n"
  	"			m\n"
  	"		)\n"
  	"\n"
  	"		//doc List uniqueCount Returns a list of list(value, count) for each unique value in self.\n"
  	"		uniqueCount := method(self unique map(item, list(item, self select(== item) size)))\n"
  	"		\n"
  	"		exSlice := getSlot(\"slice\")\n"
  	"		\n"
  	"		\n"
  	"	asJson := method(\n"
  	"		\"[\" .. self map(asJson) join(\",\") .. \"]\"\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"List ListCursor := Object clone do(\n"
  	"	newSlot(\"index\", 0)\n"
  	"	newSlot(\"collection\")\n"
  	"	next := method(index = index + 1; max := (collection size - 1); if(index > max, index = max; false, true))\n"
  	"	previous := method(index = index - 1; if(index < 0, index = 0; false, true))\n"
  	"	value := method(collection at(index))\n"
  	"	insert := method(v, collection atInsert(index, getSlot(\"v\")))\n"
  	"	remove := method(v, collection removeAt(index))\n"
  	")\n"
  	"\n"
  	"List asSimpleString := method(\n"
  	"	r := self exSlice(0, 30) asString\n"
  	"	//r := self asString\n"
  	"	if(r size > 40,\n"
  	"		r exSlice(0, 37) .. \"...\"\n"
  	"	,\n"
  	"		r\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "A3_List.io");

	s = "\n"
  	"Call do(\n"
  	"	//doc Call description Returns a description of the receiver as a String.\n"
  	"	description := method(\n"
  	"		m := self message\n"
  	"		s := self target type .. \" \" .. m name\n"
  	"		s alignLeft(36) .. \" \" .. m label lastPathComponent .. \" \" .. m lineNumber\n"
  	"	)\n"
  	"\n"
  	"	/*doc Call delegateTo(target, altSender)\n"
  	"	Sends the call's message to target (and relays it's stop status). \n"
  	"	The sender is set to altSender, if it is supplied.\n"
  	"	Returns the result of the message.\n"
  	"	*/\n"
  	"	delegateTo := method(target, altSender,\n"
  	"		call relayStopStatus(target doMessage(self message clone setNext, altSender ifNilEval(self sender)))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Call delegateToMethod(target, methodName)\n"
  	"	Sends the call's message to target via the method specified by methodName. \n"
  	"	Returns the result of the message.\n"
  	"	*/\n"
  	"	delegateToMethod := method(target, methodName,\n"
  	"		call relayStopStatus(target doMessage(self message clone setNext setName(methodName), self sender))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Call evalArgs\n"
  	"	Returns a list containing the call message arguments evaluated in the context of the sender.\n"
  	"	*/\n"
  	"	evalArgs := method(self message argsEvaluatedIn(sender)) setPassStops(true)\n"
  	"	\n"
  	"	/*doc Call hasArgs\n"
  	"	Returns true if the call was passed arguments.\n"
  	"	*/\n"
  	"	hasArgs  := method(argCount > 0)\n"
  	"	\n"
  	"	/*doc Call argCount\n"
  	"	Returns the number of arguments for the call. Same as call message argCount.\n"
  	"	*/\n"
  	"	argCount := method(self message argCount)\n"
  	")\n"
  	"\n"
  	"//doc Message description Returns a string containing a short description of the method.\n"
  	"Message description := method(\n"
  	"	self name alignLeft(36) .. self label lastPathComponent .. \" \" .. self lineNumber\n"
  	")\n"
  	"\n"
  	"Scheduler := Object clone do(\n"
  	"	//doc Scheduler yieldingCoros The List of yielding Coroutine objects.\n"
  	"	//doc Scheduler setYieldingCoros(aListOfCoros) Sets the list of yielding Coroutine objects.\n"
  	"	yieldingCoros ::= List clone\n"
  	"	\n"
  	"	//doc Scheduler timers The List of active timers.\n"
  	"	//doc Scheduler setTimers(aListOfTimers) Sets the list of active timers.\n"
  	"	timers ::= List clone\n"
  	"	\n"
  	"	//doc Scheduler currentCoroutine Returns the currently running coroutine.\n"
  	"	currentCoroutine := method(Coroutine currentCoroutine)\n"
  	"	\n"
  	"	waitForCorosToComplete := method(\n"
  	"		while(yieldingCoros size > 0, yield)	\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Coroutine do(\n"
  	"	//doc Coroutine stackSize Stack size allocated for each new coroutine. Coroutines will automatically chain themselves as need if more stack space is required.\n"
  	"	//doc Coroutine setStackSize\n"
  	"	//stackSize ::= 131072 // PPC needs 128k for current parser\n"
  	"	stackSize ::= 131072 // PPC needs 128k for current parser\n"
  	"\n"
  	"	//doc Coroutine exception Returns the current exception or nil if there is none.\n"
  	"	//doc Coroutine setException\n"
  	"	exception ::= nil\n"
  	"	\n"
  	"	//doc Coroutine parentCoroutine Returns the parent coroutine this one was chained from or nil if it wasn't chained. When a Coroutine ends, it will attempt to resume it's parent.\n"
  	"	//doc Coroutine setParentCoroutine\n"
  	"	parentCoroutine ::= nil\n"
  	"	\n"
  	"	//doc Coroutine runTarget The object which the coroutine will send a message to when it starts.\n"
  	"	//doc Coroutine setRunTarget\n"
  	"	runTarget ::= nil\n"
  	"\n"
  	"	//doc Coroutine runLocals The locals object in whose context the coroutine will send it's run message.\n"
  	"	//doc Coroutine setRunLocals\n"
  	"	runLocals ::= nil\n"
  	"\n"
  	"	//doc Coroutine runMessage The message to send to the runTarget when the coroutine starts.\n"
  	"	//doc Coroutine setRunMessage\n"
  	"	runMessage ::= nil\n"
  	"\n"
  	"	//doc Coroutine result The result set when the coroutine ends.\n"
  	"	//doc Coroutine setResult \n"
  	"	result ::= nil\n"
  	"	\n"
  	"	//doc Coroutine label A label slot useful for debugging purposes.\n"
  	"	//doc Coroutine setLabel\n"
  	"	label ::= \"\"\n"
  	"\n"
  	"	//doc Coroutine inException Set to true when processing an exception in the coroutine.\n"
  	"	//doc Coroutine setInException\n"
  	"	inException ::= false\n"
  	"	\n"
  	"	//doc Coroutine yieldingCoros Reference to Scheduler yieldingCoros.\n"
  	"	//doc Coroutine setYieldingCoros\n"
  	"	yieldingCoros ::= Scheduler yieldingCoros\n"
  	"	//doc Coroutine debugWriteln (See <tt>Object debugWriteln</tt>.)\n"
  	"	debugWriteln := nil\n"
  	"\n"
  	"	label := method(self uniqueId)\n"
  	"	setLabel := method(s, self label = s .. \"_\" .. self uniqueId)\n"
  	"  \n"
  	"  //doc Coroutine showYielding Prints a list of yielding coroutines to STDOUT.\n"
  	"	showYielding := method(s,\n"
  	"		writeln(\"   \", label, \" \", s)\n"
  	"		yieldingCoros foreach(v, writeln(\"    \", v uniqueId))\n"
  	"	)\n"
  	"	\n"
  	"  //doc Coroutine isYielding Returns true if the receiver is yielding (not paused or running).\n"
  	"	isYielding := method(yieldingCoros contains(self))\n"
  	"  \n"
  	"  /*doc Coroutine yield\n"
  	"  Yields to another coroutine in the yieldingCoros queue.\n"
  	"  Does nothing if yieldingCoros is empty.\n"
  	"  */\n"
  	"	yield := method(\n"
  	"		//showYielding(\"yield\")\n"
  	"		//writeln(\"Coro \", self uniqueId, \" yielding - yieldingCoros = \", yieldingCoros size)\n"
  	"		if(yieldingCoros isEmpty, return)\n"
  	"		yieldingCoros append(self)\n"
  	"		next := yieldingCoros removeFirst\n"
  	"		if(next == self, return)\n"
  	"		//writeln(Scheduler currentCoroutine label, \" yield - \", next label, \" resume\")\n"
  	"		if(next, next resume)\n"
  	"	)\n"
  	"\n"
  	"  /*doc Coroutine resumeLater\n"
  	"  Promotes receiver to the top of the yieldingCoros queue, but not yielding to it.\n"
  	"  When current coroutine yields, receiver will resume.\n"
  	"  */\n"
  	"	resumeLater := method(\n"
  	"		yieldingCoros remove(self)\n"
  	"		yieldingCoros atInsert(0, self)\n"
  	"		//writeln(self label, \" resumeLater\")\n"
  	"	)\n"
  	"\n"
  	"  /*doc Coroutine pause\n"
  	"	Removes current coroutine from the yieldingCoros queue and\n"
  	"	yields to another coro. <tt>System exit</tt> is executed if no coros left.\n"
  	"	<br/>\n"
  	"	You can resume a coroutine using either <tt>resume</tt> or <tt>resumeLater</tt> message.\n"
  	"  */\n"
  	"	pause := method(\n"
  	"		yieldingCoros remove(self)\n"
  	"		if(isCurrent,\n"
  	"			next := yieldingCoros removeFirst\n"
  	"			if(next,\n"
  	"				next resume\n"
  	"			,\n"
  	"				//Exception raise(\"Scheduler: nothing left to resume so we are exiting\")\n"
  	"				writeln(\"Scheduler: nothing left to resume so we are exiting\")\n"
  	"				self showStack\n"
  	"				System exit\n"
  	"			)\n"
  	"		,\n"
  	"			yieldingCoros remove(self)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"  //FIXME: these two methods are identical!!\n"
  	"  //doc Coroutine yieldCurrentAndResumeSelf Yields to a receiver.\n"
  	"	yieldCurrentAndResumeSelf := method(\n"
  	"		//showYielding(\"yieldCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"  //FIXME: these two methods are identical!!\n"
  	"  //doc Coroutine pauseCurrentAndResumeSelf Pauses current coroutine and yields to a receiver.\n"
  	"	pauseCurrentAndResumeSelf := method(\n"
  	"		//showYielding(\"pauseCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"  \n"
  	"  //doc Coroutine typeId Returns <type>_<uniqueHexId> string.\n"
  	"	typeId := method(self type .. \"_0x\" .. self uniqueId asString toBase(16))\n"
  	"    \n"
  	"  //doc Coroutine ignoredCoroutineMethodNames List of methods to ignore when building a <tt>callStack</tt>.\n"
  	"	ignoredCoroutineMethodNames := list(\"setResult\", \"main\", \"pauseCurrentAndResumeSelf\", \"resumeParentCoroutine\", \"raiseException\")\n"
  	"\n"
  	"	//doc Coroutine callStack Returns a list of Call objects.\n"
  	"	callStack := method(\n"
  	"		stack := ioStack\n"
  	"		stack selectInPlace(v, Object argIsCall(getSlot(\"v\"))) reverseInPlace\n"
  	"		stack selectInPlace(v,\n"
  	"			(v target type == \"Coroutine\" and ignoredCoroutineMethodNames contains(v message name)) not\n"
  	"		)\n"
  	"		stack foreach(i, v, if(v target type == \"Importer\" and v message name == \"import\", stack sliceInPlace(i+1); break) )\n"
  	"		stack := stack unique\n"
  	"		//if(parentCoroutine and parentCoroutine != self, stack appendSeq(parentCoroutine callStack))\n"
  	"		stack\n"
  	"	)\n"
  	"\n"
  	"    //doc Coroutine backTraceString Returns a formatted callStack output along with exception info (if any). In case of CGI script, wraps output with &lt;code&gt; tag.\n"
  	"	backTraceString := method(\n"
  	"		if(Coroutine inException,\n"
  	"			writeln(\"\\n\", exception type, \": \", exception error, \"\\n\\n\")\n"
  	"			writeln(\"Coroutine Exception loop detected\");\n"
  	"			System exit\n"
  	"		)\n"
  	"		Coroutine setInException(true)\n"
  	"		buf := Sequence clone\n"
  	"\n"
  	"		//writeln(\"backTraceString 1\\n\")\n"
  	"		if(getSlot(\"CGI\") != nil and CGI isInWebScript, buf appendSeq(\"<code>\"))\n"
  	"\n"
  	"		if(exception, buf appendSeq(\"\\n  \", exception type, \": \", exception error, \"\\n\"))\n"
  	"\n"
  	"		//writeln(\"backTraceString 2\\n\")\n"
  	"		if(callStack size > 0) then(\n"
  	"			buf appendSeq(\"  ---------\\n\")\n"
  	"\n"
  	"			if(exception and exception ?caughtMessage,\n"
  	"				buf appendSeq(\"  \", exception caughtMessage description, \"\\n\")\n"
  	"			)\n"
  	"\n"
  	"			frames := callStack\n"
  	"\n"
  	"			if(exception and exception originalCall,\n"
  	"				index := frames indexOf(exception originalCall)\n"
  	"				if(index,\n"
  	"					frames sliceInPlace(index)\n"
  	"				)\n"
  	"			)\n"
  	"\n"
  	"			frames foreach(v,\n"
  	"				buf appendSeq(\"  \", v description, \"\\n\")\n"
  	"			)\n"
  	"			buf appendSeq(\"\\n\")\n"
  	"		) else(\n"
  	"			buf appendSeq(\"  ---------\\n\")\n"
  	"			if(exception and exception caughtMessage,\n"
  	"				m := exception caughtMessage\n"
  	"				buf appendSeq(\"  message '\" .. m name .. \"' in '\" .. m label .. \"' on line \" .. m lineNumber .. \"\\n\")\n"
  	"				buf appendSeq(\"\\n\")\n"
  	"			,\n"
  	"				buf appendSeq(\"  nothing on stack\\n\")\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		Coroutine setInException(false)\n"
  	"		buf\n"
  	"	)\n"
  	"\n"
  	"	//doc Coroutine showStack Writes backTraceString to STDOUT.\n"
  	"	showStack := method(write(backTraceString))\n"
  	"    \n"
  	"	//doc Coroutine resumeParentCoroutine Pauses current coroutine and resumes parent.\n"
  	"	resumeParentCoroutine := method(\n"
  	"		if(parentCoroutine, parentCoroutine pauseCurrentAndResumeSelf)\n"
  	"	)\n"
  	"  \n"
  	"	//doc Coroutine main [Seems to be obsolete!] Executes runMessage, resumes parent coroutine.\n"
  	"	main := method(\n"
  	"		setResult(self getSlot(\"runTarget\") doMessage(runMessage, self getSlot(\"runLocals\")))\n"
  	"		resumeParentCoroutine\n"
  	"		pause\n"
  	"	)\n"
  	"  \n"
  	"	//doc Coroutine raiseException Sets exception in the receiver and resumes parent coroutine.\n"
  	"	raiseException := method(e,\n"
  	"		self setException(e)\n"
  	"		resumeParentCoroutine\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"/*doc Object wait(s)\n"
  	"Pauses current coroutine for at least <tt>s</tt> seconds.\n"
  	"<br/>\n"
  	"Note: current coroutine may wait much longer than designated number of seconds\n"
  	"depending on circumstances. \n"
  	"*/\n"
  	"\n"
  	"Object wait := method(s,\n"
  	"	//writeln(\"Scheduler yieldingCoros size = \", Scheduler yieldingCoros size)\n"
  	"	if(Scheduler yieldingCoros isEmpty,		\n"
  	"		//writeln(\"System sleep\")\n"
  	"		System sleep(s)\n"
  	"	,\n"
  	"		//writeln(\"Object wait\")\n"
  	"		endDate := Date clone now + Duration clone setSeconds(s)\n"
  	"		loop(endDate isPast ifTrue(break); yield)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Message do(\n"
  	"  /*doc Message codeOfLength(n)\n"
  	"  Same as <tt>Message code</tt>, but returns first <tt>n</tt> characters only.\n"
  	"  */\n"
  	"	codeOfLength := method(length,\n"
  	"		c := self code\n"
  	"		if (c size < length, c, c exclusiveSlice(0, length) .. \"...\") asMutable replaceSeq(\"\\n\", \";\")\n"
  	"	)\n"
  	"\n"
  	"  //doc Message asStackEntry Returns a string containing message name, file and line.\n"
  	"	asStackEntry := method(\n"
  	"		label := label lastPathComponent fileName\n"
  	"		label alignLeft(19) .. lineNumber asString alignLeft(7) .. name\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"  /*doc Object try(code)\n"
  	"  Executes particular code in a new coroutine.\n"
  	"  Returns exception or nil if no exception is caught.\n"
  	"  <br/>\n"
  	"  See also documentation for Exception catch and pass.  \n"
  	"  */\n"
  	"	try := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setParentCoroutine(Scheduler currentCoroutine)\n"
  	"		coro setRunTarget(call sender)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		coro run\n"
  	"		if(coro exception, coro exception, nil)\n"
  	"	)\n"
  	"\n"
  	"  /*doc Object coroFor(code)\n"
  	"  Returns a new coro to be run in a context of sender.\n"
  	"  */\n"
  	"	coroFor := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(call sender)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		coro\n"
  	"	)\n"
  	"\n"
  	"  /*doc Object coroDo(code)\n"
  	"  Creates a new coro to be run in a context of sender and yields to it.\n"
  	"  Returns a coro.\n"
  	"  */\n"
  	"	coroDo := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(call sender)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		Coroutine yieldingCoros atInsert(0, Scheduler currentCoroutine)\n"
  	"		coro run\n"
  	"		coro\n"
  	"	)\n"
  	"\n"
  	"  /*doc Object coroDoLater(code)\n"
  	"  Returns a new coro to be run in a context of sender.\n"
  	"  New coro is moved to the top of the yieldingCoros queue to be executed \n"
  	"  when current coro yields.\n"
  	"  <br/>\n"
  	"  Note: run target is <tt>self</tt> (i.e. receiver), not <tt>call sender</tt> as in coroDo.\n"
  	"  */\n"
  	"	coroDoLater := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(self)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		Coroutine yieldingCoros atInsert(0, coro)\n"
  	"		coro\n"
  	"	)\n"
  	"\n"
  	"  /*doc Object coroWith(code)\n"
  	"  Returns a new coro to be run in a context of receiver.\n"
  	"  */\n"
  	"	coroWith := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(self)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		coro\n"
  	"	)\n"
  	"  //doc Object currentCoro Returns the currently running coroutine.\n"
  	"	currentCoro := method(Coroutine currentCoroutine)\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"  //doc nil catch Does nothing, returns nil. See <tt>Exception catch</tt>.\n"
  	"	//doc nil pass Does nothing, returns nil. See <tt>Exception pass</tt>.\n"
  	"	catch := nil\n"
  	"	pass := nil\n"
  	")\n"
  	"\n"
  	"Protos Exception do(\n"
  	"	type := \"Exception\"\n"
  	"	newSlot(\"error\")\n"
  	"	newSlot(\"coroutine\")\n"
  	"	newSlot(\"caughtMessage\")\n"
  	"	newSlot(\"nestedException\")\n"
  	"	newSlot(\"originalCall\")\n"
  	"\n"
  	"	raise := method(error, nestedException,\n"
  	"		//writeln(\"RAISE EXCEPTION\")\n"
  	"		coro := Scheduler currentCoroutine\n"
  	"		coro raiseException(self clone setError(error) setCoroutine(coro) setNestedException(nestedException))\n"
  	"	)\n"
  	"\n"
  	"	raiseFrom := method(originalCall, error, nestedException,\n"
  	"		coro := Scheduler currentCoroutine\n"
  	"		coro raiseException(self clone setError(error) setCoroutine(coro) setNestedException(nestedException) setOriginalCall(originalCall))\n"
  	"	)\n"
  	"\n"
  	"	catch := method(exceptionProto,\n"
  	"		if (self isKindOf(exceptionProto), call evalArgAt(1); nil, self)\n"
  	"	)\n"
  	"\n"
  	"	pass := method(Scheduler currentCoroutine raiseException(self))\n"
  	"\n"
  	"	showStack := method(\n"
  	"		coroutine showStack\n"
  	"		if(nestedException,\n"
  	"				writeln(\"Nested Exception: '\", nestedException,  \"'\")\n"
  	"				nestedException showStack\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"System userInterruptHandler := method(\n"
  	"	writeln(\"\\nStack trace:\\n\")\n"
  	"	Scheduler currentCoroutine showStack\n"
  	"	exit\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "A4_Exception.io");

	s = "\n"
  	"Notifier := Object clone do(\n"
  	"	addListener := method(listener,\n"
  	"		if(self getSlot(\"listeners\") == nil, self listeners := List clone)\n"
  	"		listeners append(listener);\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	removeListener := method(obj,\n"
  	"		if(?listeners, listeners remove(obj))\n"
  	"	)\n"
  	"\n"
  	"	notifyListeners := method(\n"
  	"		if(?listeners,\n"
  	"			listeners foreach(l,\n"
  	"				if(l hasSlot(call argAt(0) name),\n"
  	"					stopStatus(l doMessage(call argAt(0), call sender))\n"
  	"				)\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"FutureProxy := Object clone do(\n"
  	"	with := method(future,\n"
  	"		p := self clone\n"
  	"		p _future := future\n"
  	"		p forward := self getSlot(\"_forward\")\n"
  	"		p _become := self getSlot(\"become\")\n"
  	"		//p xyz := method(_future writeln(\"XYZ!\"))\n"
  	"		p type := \"FutureProxy\"\n"
  	"		p removeAllProtos\n"
  	"		p\n"
  	"	)\n"
  	"\n"
  	"	_forward := method(\n"
  	"		//_future writeln(\"FutureProxy forward \", call message)\n"
  	"		_future waitOnResult\n"
  	"		self doMessage(call message, call sender)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Future := Object clone do(\n"
  	"	newSlot(\"runTarget\")\n"
  	"	newSlot(\"runMessage\")\n"
  	"	newSlot(\"waitingCoros\")\n"
  	"\n"
  	"	futureProxy := method(\n"
  	"		self waitingCoros := List clone\n"
  	"		self proxy := FutureProxy with(self)\n"
  	"		proxy\n"
  	"	)\n"
  	"\n"
  	"	setResult := method(r,\n"
  	"		if(self hasSlot(\"proxy\"),\n"
  	"			proxy _become(getSlot(\"r\"))\n"
  	"			if(waitingCoros, waitingCoros foreach(resumeLater))\n"
  	"			//notifyListeners(futureReady(self))\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	waitOnResult := method(\n"
  	"		waitingCoros append(Scheduler currentCoroutine)\n"
  	"		Scheduler currentCoroutine pause\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"/*\n"
  	"Object do(\n"
  	"	actorIsRunning := method(\n"
  	"		//writeln(\"self hasLocalSlot(actorCoroutine) = \", self hasLocalSlot(\"actorCoroutine\"))\n"
  	"		if(self hasLocalSlot(\"actorCoroutine\"),\n"
  	"			writeln(\"actorQueue size = \", actorQueue size)\n"
  	"			writeln(\"Coroutine yieldingCoros contains(actorCoroutine) = \", Coroutine yieldingCoros contains(actorCoroutine))\n"
  	"			writeln(\"Coroutine currentCoroutine == actorCoroutine = \", Coroutine currentCoroutine == actorCoroutine)\n"
  	"		)\n"
  	"\n"
  	"		self hasLocalSlot(\"actorCoroutine\") and(actorQueue size > 0) and(\n"
  	"			Coroutine yieldingCoros contains(actorCoroutine) or(Coroutine currentCoroutine == actorCoroutine)\n"
  	"		)\n"
  	"	)\n"
  	"	actorIsPaused := method(self hasLocalSlot(\"actorCoroutine\") and(actorQueue size > 0))\n"
  	"	actorPause := method(if(actorIsPaused, actorCoroutine pause))\n"
  	"	actorResume := method(if(actorIsPaused, actorCoroutine resumeLater))\n"
  	")\n"
  	"*/\n"
  	"\n"
  	"Object do(\n"
  	"  /*doc Object yield\n"
  	"  Yields to another coroutine. Does nothing if yieldingCoros queue is empty.\n"
  	"  <br/>\n"
  	"  See Coroutine documentation for more details.\n"
  	"  */\n"
  	"	yield := method(Coroutine currentCoroutine yield)\n"
  	"	\n"
  	"	/*doc Object pause\n"
  	"	Removes current coroutine from the yieldingCoros queue and\n"
  	"	yields to another coro. Exits if no coros left.\n"
  	"	<br/>\n"
  	"  See Coroutine documentation for more details.\n"
  	"  */\n"
  	"	pause := method(Coroutine currentCoroutine pause)\n"
  	"\n"
  	"  //doc Object actorRun Starts actor mode if not started already. Basically, sets actorProcessQueue for later execution.\n"
  	"	actorRun := method(\n"
  	"		if(self hasLocalSlot(\"actorCoroutine\"),\n"
  	"			if(actorQueue size == 0, self actorCoroutine resumeLater)\n"
  	"		,\n"
  	"			self actorQueue := List clone\n"
  	"			// need to yield in coroDo to allow future to be added to queue\n"
  	"			//self actorCoroutine := self coroDo(yield; actorProcessQueue) // coroDo refs stack!\n"
  	"			self actorCoroutine := Coroutine clone //setStackSize(20000)\n"
  	"			actorCoroutine setRunTarget(self)\n"
  	"			actorCoroutine setRunLocals(self)\n"
  	"			actorCoroutine setRunMessage(message(actorProcessQueue))\n"
  	"			Coroutine yieldingCoros atInsert(0, actorCoroutine)\n"
  	"			//Coroutine yieldingCoros append(actorCoroutine)\n"
  	"		)\n"
  	"	)\n"
  	"  \n"
  	"  //doc Object actorProcessQueue Processes each message in a queue, yielding between each message.\n"
  	"\n"
  	"	actorProcessQueue := method(\n"
  	"		//writeln(self type, \"_\", self uniqueId, \" actorProcessQueue\")\n"
  	"\n"
  	"		/*\n"
  	"		if(Coroutine currentCoroutine isIdenticalTo(self actorCoroutine) not,\n"
  	"			writeln(\"actorProcessQueue called from coro \", Coroutine currentCoroutine uniqueId, \" instead of \", actorCoroutine uniqueId)\n"
  	"			System exit\n"
  	"		)\n"
  	"		*/\n"
  	"\n"
  	"		loop(\n"
  	"			while(future := actorQueue first,\n"
  	"				e := try(\n"
  	"					future setResult(self doMessage(future runMessage))\n"
  	"					//stopStatus(future setResult(self doMessage(future runMessage)))\n"
  	"				)\n"
  	"				actorQueue removeFirst\n"
  	"				if(e, handleActorException(e))\n"
  	"				if(actorQueue first, yield)\n"
  	"			)\n"
  	"\n"
  	"/*\n"
  	"			if(Coroutine currentCoroutine isIdenticalTo(self actorCoroutine) not,\n"
  	"				writeln(\"actorProcessQueue1 called from coro \", Coroutine currentCoroutine uniqueId, \" instead of \", self actorCoroutine uniqueId)\n"
  	"				System exit\n"
  	"			)\n"
  	"*/\n"
  	"			self actorCoroutine pause\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"  /*doc Object handleActorException(exception)\n"
  	"  Callback for handling exceptions during asynchronous message processing.\n"
  	"  <br/>\n"
  	"  Default value: method(e, e showStack)\n"
  	"  */\n"
  	"	handleActorException := method(e, e showStack)\n"
  	"    \n"
  	"  /*doc Object @\n"
  	"  Sends asynchronous message to an object, returns a FutureProxy.\n"
  	"  <br/>\n"
  	"  Caller coroutine is paused when proxy is accessed (i.e. message is sent)\n"
  	"  till result is ready. Proxy will become an actual result when it is ready.\n"
  	"  <br/>\n"
  	"  See IoGuide for more information.\n"
  	"  <br/>\n"
  	"  Usage: obj @someMethod(a, b, c)\n"
  	"  */\n"
  	"	setSlot(\"@\", method(\n"
  	"		//writeln(\"@ \", call argAt(0))\n"
  	"		m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"		f := Future clone setRunTarget(self) setRunMessage(m)\n"
  	"		self actorRun\n"
  	"		self actorQueue append(f)\n"
  	"		f futureProxy\n"
  	"	))\n"
  	"  \n"
  	"  /*doc Object @@\n"
  	"  Same as Object @, but returns nil instead of FutureProxy.\n"
  	"  <br/>\n"
  	"  Might be useful in a command line or as a last expression in a block/method when\n"
  	"  you don't want to return a future.\n"
  	"  */\n"
  	"	setSlot(\"@@\", method(\n"
  	"		//writeln(self type , \"_\", self uniqueId, \" @@\", call argAt(0)) //, \" \", call argAt(0) label)\n"
  	"		m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"		f := Future clone setRunTarget(self) setRunMessage(m)\n"
  	"		self actorRun\n"
  	"		self actorQueue append(f)\n"
  	"		nil\n"
  	"	))\n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Actor.io");

	s = "Addon := Object clone do(\n"
  	"	//doc Addon rootPath Returns the rootPath of the addon's folder.\n"
  	"	//doc Addon setRootPath(aSequence) Sets rootPath of the addon's folder. Returns self.\n"
  	"	newSlot(\"rootPath\")\n"
  	"\n"
  	"	//doc Addon name Returns the name of the addon.\n"
  	"	//doc Addon setName(aSequence) Sets the name of the addon. Returns self.\n"
  	"	newSlot(\"name\")\n"
  	"\n"
  	"	//doc Addon platform Implemented as method(System platform asLowercase).\n"
  	"	platform := System platform asLowercase\n"
  	"\n"
  	"	//doc Addon dllSuffix Returns the platform specific dll suffix.\n"
  	"	dllSuffix := method(\n"
  	"	  list(\"cygwin\", \"mingw\", \"windows\") detect(dllPlatform, platform containsSeq(dllPlatform)) ifNonNil(return(\"dll\"))\n"
  	"	  if(platform == \"darwin\", return \"dylib\")\n"
  	"	  \"so\"\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon dllName Return the name of the dll for the addon.\n"
  	"	dllName := method(\"libIo\" .. name .. \".\" .. dllSuffix)\n"
  	"\n"
  	"	//doc Addon addonPath Implemented as Path with(rootPath, name).\n"
  	"	addonPath := method(Path with(rootPath, name))\n"
  	"\n"
  	"	//doc Addon dllPath Returns the path to the dll for the addon. Note: not all addons have dlls - some just contain io files.\n"
  	"	dllPath := method(Path with(addonPath, \"_build/dll\", dllName))\n"
  	"\n"
  	"	//doc Addon sourcePath Returns the path of the source folder for the addon.\n"
  	"	sourcePath := method(Path with(addonPath, \"source\"))\n"
  	"\n"
  	"	//doc Addon ioFiles Return list of io File objects for the io files in the io folder of the addon.\n"
  	"	ioFiles := method(\n"
  	"		d := Directory with(addonPath) directoryNamed(\"io\")\n"
  	"		if(d exists not, return list())\n"
  	"		files := d files select(path endsWithSeq(\".io\"))\n"
  	"		files map(name) sort map(name, d fileNamed(name))\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon dependencies Returns the list of dependencies from the addon's depends file.\n"
  	"	dependencies := method(\n"
  	"		File with(Path with(addonPath, \"depends\")) contents split(\" \")\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon loadDependencies Loads the addon's dependencies. Called from the load method.\n"
  	"	loadDependencies := method(\n"
  	"		//writeln(name, \" depends on \", dependencies)\n"
  	"		dependencies foreach(d,\n"
  	"			if(Lobby getSlot(d) == nil,\n"
  	"				//writeln(\"loading dependency \", d)\n"
  	"				AddonLoader loadAddonNamed(d)\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon load Loads the addon.\n"
  	"	load := method(\n"
  	"		//writeln(\"Addon \", name, \" loading from \", addonPath)\n"
  	"		loadDependencies\n"
  	"		context := Object clone\n"
  	"		Protos Addons setSlot(name, context)\n"
  	"		Protos appendProto(context)\n"
  	"		//writeln(dllPath)\n"
  	"		if(File with(dllPath) exists,\n"
  	"			DynLib clone setPath(dllPath) open call(\"Io\" .. name .. \"Init\", context)\n"
  	"		,\n"
  	"			// check for C files, if found then addon didn't compile\n"
  	"			if(Directory with(sourcePath) files size > 1,\n"
  	"				Exception raise(\"Failed to load Addon \" .. name .. \" - it appears that the addon exists but was not compiled. You might try running 'make \" .. name .. \"' in the Io source folder.\")\n"
  	"			)\n"
  	"		)\n"
  	"		//ioFiles foreach(f, writeln(\"loading \", f path))\n"
  	"		ioFiles foreach(file, context doFile(file path))\n"
  	"		Lobby getSlot(name)\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon exists Returns true if the addonPath exists, false otherwise.\n"
  	"	exists := method(Directory with(addonPath) exists)\n"
  	"\n"
  	"	//doc Addon addonProtos Returns names of protos defined in the addon from the addon's protos file.\n"
  	"	addonProtos := method(\n"
  	"		f := File with(Path with(addonPath, \"protos\"))\n"
  	"		if(f exists, f contents split, list())\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"AddonLoader := Object clone do(\n"
  	"	//doc Addon searchPaths Returns the list of paths to search for addons.\n"
  	"	searchPaths := list(\"io/addons\", System installPrefix .. \"/lib/io/addons\")\n"
  	"\n"
  	"	//doc Addon appendSearchPath(aSequence) Appends the argument to the list of search paths.\n"
  	"	appendSearchPath := method(p, searchPaths appendIfAbsent(p); self)\n"
  	"\n"
  	"	//doc Addon addons Looks for all addons which can be found and returns them as a list of Addon objects. Caches the result the first time it is called.\n"
  	"	addons := method(\n"
  	"		searchFolders := searchPaths map(path, Directory with(path)) select(exists)\n"
  	"		addonFolders := searchFolders map(directories) flatten select(isAccessible) select(fileNames contains(\"build.io\"))\n"
  	"		self addons := addonFolders map(f, Addon clone setRootPath(f path pathComponent) setName(f path lastPathComponent))\n"
  	"		addons\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon addonFor(aName) Returns the Addon with the given name if it can be found or nil otherwise.\n"
  	"	addonFor := method(name,\n"
  	"		r := addons detect(name == name)\n"
  	"		if(r, return r)\n"
  	"		addons detect(addonProtos contains(name))\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon hasAddonNamed(aName) Returns true if the named addon can be found, false otherwise.\n"
  	"	hasAddonNamed := method(name, addonFor(name) != nil)\n"
  	"\n"
  	"	//doc Addon loadAddonNamed(aName) Loads the Addon with the given name if it can be found or nil otherwise.\n"
  	"	loadAddonNamed := method(name,\n"
  	"		//writeln(\"loadAddonNamed(\", name, \")\")\n"
  	"		addon := addonFor(name)\n"
  	"		if(addon, addon load, nil)\n"
  	"		Lobby getSlot(name)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "AddonLoader.io");

	s = "getSlot(\"Block\") do(\n"
  	"\n"
  	"	//doc Block asSimpleString Returns a short description of the receiver.\n"
  	"	asSimpleString := method(\n"
  	"		if(scope, \"block\", \"method\") .. \"(\" .. argumentNames append(\"...\") join(\", \") .. \")\"\n"
  	"	)\n"
  	"\n"
  	"	//doc Block asString Returns a full description of the receiver with decompiled code.\n"
  	"	asString := method(\n"
  	"		Formatter clone formatBlock(getSlot(\"self\")) buffer\n"
  	"	)\n"
  	"\n"
  	"	print := method(\n"
  	"		writeln\n"
  	"		writeln(asString)\n"
  	"	)\n"
  	"\n"
  	"  //doc Block println Same as <tt>print</tt>.\n"
  	"	println := getSlot(\"print\")\n"
  	"    \n"
  	"  //doc Block Formatter Helper object for the <tt>asString</tt> method.\n"
  	"	Formatter := Object clone do(\n"
  	"		newSlot(\"lineNumber\", 0)\n"
  	"		newSlot(\"isLineEmpty\", true)\n"
  	"		newSlot(\"depth\", 0)\n"
  	"		newSlot(\"buffer\")\n"
  	"\n"
  	"		newSlot(\"operators\")\n"
  	"		newSlot(\"reverseAssignOperators\")\n"
  	"\n"
  	"		init := method(\n"
  	"			buffer = Sequence clone\n"
  	"			operators = OperatorTable operators\n"
  	"			reverseAssignOperators = OperatorTable reverseAssignOperators\n"
  	"			reverseAssignOperators atPut(\"setSlotWithType\", \":=\")\n"
  	"		)\n"
  	"\n"
  	"		appendSeq := method(\n"
  	"			call delegateTo(buffer)\n"
  	"			isLineEmpty = false\n"
  	"		)\n"
  	"\n"
  	"		newLine := method(\n"
  	"			buffer appendSeq(\"\\n\")\n"
  	"			lineNumber = lineNumber + 1\n"
  	"			isLineEmpty = true\n"
  	"		)\n"
  	"\n"
  	"		newLinesTo := method(msg,\n"
  	"			(msg lineNumber - lineNumber) minMax(0, 2) repeat(newLine)\n"
  	"			lineNumber = msg lineNumber\n"
  	"		)\n"
  	"\n"
  	"		indent := method(\n"
  	"			depth repeat(appendSeq(\"    \"))\n"
  	"		)\n"
  	"\n"
  	"		formatBlock := method(theBlock,\n"
  	"			msg := getSlot(\"theBlock\") message\n"
  	"\n"
  	"			if(msg label != CLI commandLineLabel,\n"
  	"				appendSeq(\"# \" .. msg label .. \":\" .. msg lineNumber, \"\\n\")\n"
  	"			)\n"
  	"			appendSeq(\"method(\")\n"
  	"			if(getSlot(\"theBlock\") argumentNames size > 0,\n"
  	"				getSlot(\"theBlock\") argumentNames foreach(i, name,\n"
  	"					if(i > 0,\n"
  	"						appendSeq(\", \")\n"
  	"					)\n"
  	"\n"
  	"					appendSeq(name)\n"
  	"				)\n"
  	"\n"
  	"				appendSeq(\", \")\n"
  	"			)\n"
  	"\n"
  	"			newLine\n"
  	"			lineNumber = msg lineNumber\n"
  	"			formatIndentedMessage(msg)\n"
  	"			newLine\n"
  	"			appendSeq(\")\")\n"
  	"			self\n"
  	"		)\n"
  	"\n"
  	"		formatIndentedMessage := method(msg,\n"
  	"			depth = depth + 1\n"
  	"			formatMessage(msg)\n"
  	"			depth = depth - 1\n"
  	"		)\n"
  	"\n"
  	"		formatMessage := method(msg,\n"
  	"			m := msg\n"
  	"			while(m,\n"
  	"				if(m isEndOfLine,\n"
  	"					if(lineNumber == m next ?lineNumber,\n"
  	"						appendSeq(m name)\n"
  	"					)\n"
  	"					m = m next\n"
  	"					continue\n"
  	"				)\n"
  	"\n"
  	"				newLinesTo(m)\n"
  	"\n"
  	"				if(isLineEmpty,\n"
  	"					indent\n"
  	"				,\n"
  	"					if(m != msg,\n"
  	"						appendSeq(\" \")\n"
  	"					)\n"
  	"				)\n"
  	"\n"
  	"				if(reverseAssignOperators hasKey(m name)) then(\n"
  	"					args := m arguments\n"
  	"\n"
  	"					if(args first cachedResult,\n"
  	"						appendSeq(args first cachedResult, \" \")\n"
  	"\n"
  	"						appendSeq(reverseAssignOperators at(m name))\n"
  	"\n"
  	"						appendSeq(\" \")\n"
  	"						if(args at(1),\n"
  	"							formatMessage(args at(1))\n"
  	"						)\n"
  	"					,\n"
  	"						appendSeq(m name)\n"
  	"						if(m argCount > 0,\n"
  	"							formatArguments(m)\n"
  	"						)\n"
  	"					)\n"
  	"				) elseif(operators hasKey(m name)) then(\n"
  	"					appendSeq(m name)\n"
  	"\n"
  	"					appendSeq(\" \")\n"
  	"					if(m arguments first,\n"
  	"						formatMessage(m arguments first)\n"
  	"					)\n"
  	"				) else(\n"
  	"					appendSeq(m name)\n"
  	"					if(m argCount > 0,\n"
  	"						formatArguments(m)\n"
  	"					)\n"
  	"				)\n"
  	"\n"
  	"				m = m next\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		formatArguments := method(msg,\n"
  	"			appendSeq(\"(\")\n"
  	"\n"
  	"			startingLineNumber := lineNumber\n"
  	"			msg arguments foreach(i, arg,\n"
  	"				# Insert separator between arguments\n"
  	"				if(i > 0,\n"
  	"					# Still on the same line as the \"(\"\n"
  	"					if(startingLineNumber == lineNumber,\n"
  	"						appendSeq(\", \")\n"
  	"					,\n"
  	"						newLine; indent; appendSeq(\",\"); newLine\n"
  	"					)\n"
  	"				)\n"
  	"\n"
  	"				# Format the argument\n"
  	"				formatIndentedMessage(arg)\n"
  	"			)\n"
  	"\n"
  	"			if(startingLineNumber != lineNumber,\n"
  	"				newLine\n"
  	"				indent\n"
  	"			)\n"
  	"			appendSeq(\")\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Block.io");

	s = "\n"
  	"Vector := Sequence clone setItemType(\"float32\") setEncoding(\"number\")\n"
  	"vector := method(v := Vector clone; call evalArgs foreach(n, v append(n)); v)\n"
  	"\n"
  	"\n"
  	"/*\n"
  	"Object moveSlotToObject := method(slotName, target,\n"
  	"	v := self getSlot(slotName)\n"
  	"	self removeSlot(slotName)\n"
  	"	target setSlot(slotName, getSlot(\"v\"))\n"
  	"	writeln(self type, \" removeSlot(\\\"\", slotName, \"\\\")\")\n"
  	")\n"
  	"\n"
  	"\n"
  	"list(\"*\", \"*=\", \"+\", \"+=\", \"-\", \"-=\", \"..\", \"/\", \"/=\", \"<\", \n"
  	"\"<=\", \">\", \">=\", \"Max\", \"Min\", \"abs\", \"acos\", \"addEquals\", \"asin\", \n"
  	"\"bitAt\", \"bitCount\", \"bitwiseAnd\", \"bitwiseNot\", \"bitwiseOr\", \"bitwiseXor\", \"byteAt\", \"ceil\", \n"
  	"\"cos\", \"cosh\", \"distanceTo\", \"dotProduct\", \"duplicateIndexes\", \"isZero\", \n"
  	"\"log\", \"log10\", \"logicalOr\", \"max\", \"mean\", \"meanSquare\", \"min\", \"negate\", \"normalize\",  \n"
  	"\"product\", \"rangeFill\", \"removeEvenIndexes\", \"removeOddIndexes\", \"rootMeanSquare\", \n"
  	"\"setX\", \"setY\", \"setZ\", \"sin\", \"sinh\", \"sort\", \"sqrt\", \"square\", \"sum\", \n"
  	"\"tan\", \"tanh\", \"toBase\", \"translate\", \"x\", \"y\", \"z\", \"zero\") foreach(slotName, Sequence moveSlotToObject(slotName, Vector))\n"
  	"\n"
  	"Sequence appendProto(Vector)\n"
  	"*/\n"
  	"\n"
  	"Lobby Protos Core do(\n"
  	"	ImmutableSequence := \"\"\n"
  	"	String := ImmutableSequence\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"	validEncodings := \"ascii utf8 ucs2 ucs4 number\" split\n"
  	"	validItemTypes := \"uint8 uint16 uint32 uint64 int8 int16 int32 int64 float32 float64\" split\n"
  	"	setSlot(\"..\", method(arg, self asString cloneAppendSeq(arg asString)))\n"
  	"\n"
  	"	//doc Sequence repeated(n) Returns a new sequence containing the receiver repeated n number of times.\n"
  	"	repeated := method(n,\n"
  	"		s := Sequence clone\n"
  	"		n repeat(s appendSeq(self))\n"
  	"		s\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence alignLeftInPlace(width, [padding]) Same as align left but operation is performed on the receiver.\n"
  	"	alignLeftInPlace := method(width, padding,\n"
  	"		originalSize := size\n"
  	"		if(padding isNil or padding size == 0,\n"
  	"			padding = \" \"\n"
  	"		)\n"
  	"		((width - size) / padding size) ceil repeat(appendSeq(padding))\n"
  	"		setSize(width max(originalSize))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Sequence alignLeft(width, [padding]) \n"
  	"	Example:\n"
  	"	<p>\n"
  	"	<code>\n"
  	"	Io> \"abc\" alignLeft(10, \"+\")\n"
  	"	==> abc+++++++\n"
  	"	Io> \"abc\" alignLeft(10, \"-=\")\n"
  	"	==> abc-=-=-=-\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	alignLeft := method(width, padding, asMutable alignLeftInPlace(width, padding))\n"
  	"\n"
  	"	/*doc Sequence alignRight(width, [padding]) \n"
  	"	Example:\n"
  	"	<p>\n"
  	"	<code>\n"
  	"	Io> \"abc\" alignRight(10, \"-\")\n"
  	"	==> -------abc\n"
  	"	Io> \"abc\" alignRight(10, \"-=\")\n"
  	"	==> -=-=-=-abc\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	alignRight := method(width, padding,\n"
  	"		Sequence clone alignLeftInPlace(width - size, padding) appendSeq(self)\n"
  	"	)\n"
  	"\n"
  	"	/*doc Sequence alignCenter(width, [padding]) \"\"\n"
  	"	Example:\n"
  	"	<code>\n"
  	"	Io> \"abc\" alignCenter(10, \"-\")\n"
  	"	==> ---abc----\n"
  	"	Io> \"abc\" alignCenter(10, \"-=\")\n"
  	"	==> -=-abc-=-=\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	alignCenter := method(width, padding,\n"
  	"		alignRight(((size + width) / 2) floor, padding) alignLeftInPlace(width, padding)\n"
  	"	)\n"
  	"\n"
  	"	asSimpleString := method(\"\\\"\" .. self asString asMutable escape .. \"\\\"\")\n"
  	"\n"
  	"	/*doc Sequence splitNoEmpties(optionalArg1, optionalArg2, ...)\n"
  	"		Returns a list containing the non-empty sub-sequences of the receiver divided by the given arguments.\n"
  	"		If no arguments are given the sequence is split on white space.\n"
  	"		Examples:\n"
  	"		<code>\n"
  	"		\"a   b  c d\" splitNoEmpties => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b**c*d\" splitNoEmpties(\"*\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b||c,d\" splitNoEmpties(\"*\", \"|\", \",\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		</code>\n"
  	"	*/\n"
  	"\n"
  	"	/*doc Sequence split Returns a list containing the sub-sequences of the receiver divided by the given arguments.\n"
  	"		If no arguments are given the sequence is split on white space.\n"
  	"	*/\n"
  	"		\n"
  	"	splitNoEmpties := method(\n"
  	"		self performWithArgList(\"split\", call evalArgs) selectInPlace(size != 0)\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence findNthSeq(aSequence, n) Returns a number with the nth occurence of aSequence.\n"
  	"	findNthSeq := method(str, n,\n"
  	"		num := self findSeq(str)\n"
  	"		if(num isNil, return nil)\n"
  	"		if(n == 1, return num)\n"
  	"		num + self exclusiveSlice(num + 1, self size) findNthSeq(str, n - 1)\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	orderedSplit := method(\n"
  	"			separators := call evalArgs\n"
  	"			if(separators size == 0, return list(self))\n"
  	"			i := 0\n"
  	"			skipped := 0\n"
  	"			r := list\n"
  	"			separators foreach(separator,\n"
  	"				j := findSeq(separator, i) ifNil(\n"
  	"					skipped = skipped + 1\n"
  	"					continue\n"
  	"				)\n"
  	"				r append(exclusiveSlice(i, j))\n"
  	"				if(skipped > 0,\n"
  	"					skipped repeat(r append(nil))\n"
  	"					skipped = 0\n"
  	"				)\n"
  	"				i = j + separator size\n"
  	"			)\n"
  	"			if(size == 0,\n"
  	"				r append(nil)\n"
  	"			,\n"
  	"				r append(exclusiveSlice(i))\n"
  	"			)\n"
  	"			skipped repeat(r append(nil))\n"
  	"			r\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence prependSeq(object1, object2, ...) Prepends given objects asString in reverse order to the receiver.  Returns self.\")\n"
  	"	prependSeq := method(self atInsertSeq(0, call evalArgs join); self)\n"
  	"\n"
  	"	//doc Sequence itemCopy Returns a new sequence containing the items from the receiver.\n"
  	"	itemCopy := method(Sequence clone copy(self))\n"
  	"\n"
  	"	sequenceSets := Map clone do(\n"
  	"		atPut(\"lowercaseSequence\",\n"
  	"			lst := list\n"
  	"			\"abcdefghijklmnopqrstuvwxyz\" foreach(v, lst append(v))\n"
  	"			lst\n"
  	"		)\n"
  	"		atPut(\"uppercaseSequence\",\n"
  	"			lst := list\n"
  	"			at(\"lowercaseSequence\") foreach(v, lst append(v asUppercase))\n"
  	"			lst\n"
  	"		)\n"
  	"		atPut(\"digitSequence\",\n"
  	"			lst := list\n"
  	"			\"0123456789\" foreach(v, lst append(v))\n"
  	"			lst\n"
  	"		)\n"
  	"		removeSlot(\"lst\")\n"
  	"		removeSlot(\"v\")\n"
  	"	)\n"
  	"	\n"
  	"	//doc Sequence reverse Reverses the ordering of all the items of the receiver. Returns copy of receiver.\n"
  	"	reverse := method(self itemCopy reverseInPlace)\n"
  	"\n"
  	"	//doc Sequence asHex Returns a hex string for the receiving sequence, e.g., \\\"abc\\\" asHex -> \\\"616263\\\".\")\n"
  	"	asHex := method(\n"
  	"		r := Sequence clone\n"
  	"		self foreach(c, r appendSeq(c asHex))\n"
  	"		r\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence print Prints contents of a sequence.\n"
  	"	cPrint := getSlot(\"print\")\n"
  	"	print := method(\n"
  	"		self asUTF8 cPrint\n"
  	"	)\n"
  	"	\n"
  	"	asDecodedList := method(List fromEncodedList(self))\n"
  	"	\n"
  	"	//doc Sequence slice Deprecated method. Use exSlice instead.\n"
  	"	slice := method(start,\n"
  	"		deprecatedWarning(\"exSlice\")\n"
  	"		performWithArgList(\"exSlice\", call evalArgs)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Sequence asJson Converts to form that could be interpreted as json if it already contains json, e.g. {\"aaa\":\"bbb\"} --> \"{\\\"aaa\\\":\\\"bbb\\\"}\"\n"
  	"	asJson := method(\n"
  	"		//TODO Return unicode string with hex replacements as per http://www.json.org/\n"
  	"		replacementMap := Map clone\\\n"
  	"			atPut(\"\\\"\", \"\\\\\\\"\")\\\n"
  	"			atPut(\"/\", \"\\\\/\")\\\n"
  	"			atPut(\"\\b\", \"\\\\b\")\\\n"
  	"			atPut(\"\\f\", \"\\\\f\")\\\n"
  	"			atPut(\"\\n\", \"\\\\n\")\\\n"
  	"			atPut(\"\\t\", \"\\\\t\")\n"
  	"			\n"
  	"		\n"
  	"		\"\\\"\" .. self asMutable replaceSeq(\"\\\\\", \"\\\\\\\\\") replaceMap(replacementMap) .. \"\\\"\"\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "B_Sequence.io");

	s = "getSlot(\"CFunction\") do(\n"
  	"\n"
  	"	//doc CFunction name Returns the CFunction name in the form CFunction_Pointer.\")\n"
  	"	name := method(typeName ifNilEval(\"Object\") .. \"_\" .. uniqueName ifNilEval(\"<unnamed>\") .. \"()\")\n"
  	"\n"
  	"	//doc CFunction asSimpleString Returns the CFunction name.\n"
  	"	asSimpleString := method(name)\n"
  	"\n"
  	"	//doc CFunction asString Same as asSimpleString.\n"
  	"	asString := getSlot(\"asSimpleString\")\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "CFunction.io");

	s = "Date do(\n"
  	"	/*doc Date today \n"
  	"	Set the receiver to the current date, no time information\n"
  	"	is included. See `now' for the current date and time.\n"
  	"	*/\n"
  	"	\n"
  	"	today := method(Date now setHour(0) setMinute(0) setSecond(0))\n"
  	"\n"
  	"	//doc Date isToday Returns true if the receiver's date is today's date.\n"
  	"	isToday := method(\n"
  	"		now := Date clone now\n"
  	"		now year == year and now month == month and now day == day\n"
  	"	)\n"
  	"\n"
  	"	//doc Date secondsToRun(expression) Evaluates message and returns a Number whose value is the number of seconds taken to do the evaluation\n"
  	"	secondsToRun := method(\n"
  	"		t1 := Date clone now\n"
  	"		call relayStopStatus(call evalArgAt(0))\n"
  	"		dt := Date clone now secondsSince(t1)\n"
  	"	)\n"
  	"\n"
  	"	//doc Date asAtomDate Returns the date formatted as a valid atom date (rfc4287) in the system's timezone.\n"
  	"	Date asAtomDate := method(\n"
  	"		asString(\"%Y-%m-%dT%H:%M:%S\") .. gmtOffset asMutable atInsertSeq(3, \":\")\n"
  	"	)\n"
  	"	\n"
  	"	asJson := method(asString asJson)\n"
  	"			\n"
  	"	justSerialized := method(stream,\n"
  	"		stream write(\"Date clone do(\",\n"
  	"			\"setYear(\", self year, \") \",\n"
  	"			\"setMonth(\", self month, \") \",\n"
  	"			\"setDay(\", self day, \") \",\n"
  	"			\"setHour(\", self hour, \") \",\n"
  	"			\"setMinute(\", self minute, \") \",\n"
  	"			\"setSecond(\", self second, \")\",\n"
  	"			\");\")\n"
  	"	)\n"
  	"	\n"
  	"	asNumberString := method(\n"
  	"		self asNumber asString alignLeft(27, \"0\")\n"
  	"	)\n"
  	"	\n"
  	"	timeStampString := method(\n"
  	"		Date clone now asNumber asString alignLeft(27, \"0\")\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Duration do(\n"
  	"	//doc Duration + Returns a new Duration of the two added.\n"
  	"	setSlot(\"+\", method(d, self clone += d))\n"
  	"\n"
  	"	//doc Duration - Returns a new Duration of the two subtracted.\n"
  	"	setSlot(\"-\", method(d, self clone -= d))\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Date.io");

	s = "Debugger do(\n"
  	"	/*doc Debugger description\n"
  	"	To start debugging a coroutine, call\n"
  	"	<code>\n"
  	"	Coroutine currentCoroutine setMessageDebugging(true)\n"
  	"	</code>\n"
  	"	Then each message sent within that coroutine will cause the Debugger \n"
  	"	vmWillSendMessage slot to be activated and the Debugger slots: \n"
  	"	messageCoroutine, messageSelf, messageLocals, and message will be set with the \n"
  	"	values related to the current message send. You can override vmWillSendMessage to \n"
  	"	implement your own debugging mechanisms.\n"
  	"	*/\n"
  	"\n"
  	"	//doc Debugger start Starts the debugger.\n"
  	"	start := method(\n"
  	"		loop(\n"
  	"			self vmWillSendMessage(self message name)\n"
  	"			messageCoroutine resume\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Debugger vmWillSendMessage Override this method to implement your own debugging mechanisms. Default behavior is to print every message sent.\n"
  	"	vmWillSendMessage := method(\n"
  	"		writeln(\"Debugger vmWillSendMessage(\", self message name, \")\")\n"
  	"	)\n"
  	"\n"
  	"	//doc Debugger debuggerCoroutine Returns the coroutine used for the debugger.\n"
  	"	debuggerCoroutine := coroFor(start)\n"
  	"	yield\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Debugger.io");

	s = "\n"
  	"Directory do(\n"
  	"	//doc Directory with(aPath) Returns a new instance with the provided path.\n"
  	"	with := method(path, self clone setPath(path))\n"
  	"\n"
  	"	//doc Directory recursiveFilesOfTypes(suffixes) Returns a list containing all files in the directory or any subdirectory that has any of the specified suffixes.\n"
  	"	recursiveFilesOfTypes := method(types, aList,\n"
  	"		if(aList == nil, aList := List clone)\n"
  	"		aList appendSeq(files select(file, types containsSeq(file path pathExtension)))\n"
  	"		directories foreach(recursiveFilesOfTypes(types, aList))\n"
  	"		aList\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory recursiVeFilesOftypes(suffixes) Deprecated. Alias for recursiveFilesOfTypes(suffixes).\n"
  	"	recursiVeFilesOfTypes := method(types, aList,\n"
  	"		deprecatedWarning(\"recursiveFilesOfTypes\")\n"
  	"		recursiveFilesOfTypes(types, aList)\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory createIfAbsent Creates the directory (and any missing ancestor directories) if they don't exist. Returns self.\n"
  	"	createIfAbsent := method(\n"
  	"		if(self exists not, \n"
  	"			if(parentDirectory and parentDirectory exists not, parentDirectory createIfAbsent)\n"
  	"			self create\n"
  	"		) \n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory parentDirectory Returns the parent directory object or nil if there is no parent directory.\n"
  	"	parentDirectory := method(\n"
  	"		if(path == \".\", return nil)\n"
  	"		p := self path pathComponent\n"
  	"		if(p == \"\", p = \".\")\n"
  	"		Directory clone setPath(p)\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory directories Returns a list of subdirectories in the receiver.\n"
  	"	directories := method(\n"
  	"		items select(item, item type ==(\"Directory\") and(item name != \".\") and(item name != \"..\"))\n"
  	"	)\n"
  	"	\n"
  	"	//doc Directory folders Deprecated. Replaced by directories().\n"
  	"	folders := method(\n"
  	"		deprecatedWarning(\"directories()\")\n"
  	"		directories\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory isAccessible Returns true if the directory can be accessed, false otherwise.\n"
  	"	isAccessible := method(\n"
  	"		r := true\n"
  	"		e := try(items)\n"
  	"		e catch(Exception, r = false)\n"
  	"		r\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory ancestorDirectories Returns a list of ancestor directories.\n"
  	"	ancestorDirectories := method(\n"
  	"		list := List clone\n"
  	"		d := self\n"
  	"		while(d = d parentDirectory, list append(d))\n"
  	"		list reverseInPlace\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory accessibleAncestors Returns a list of accessizble ancestor directories.\n"
  	"	accessibleAncestors := method(ancestorDirectories select(isAccessible))\n"
  	"	\n"
  	"	//doc Directory parents Deprecated. Replaced by ancestorDirectories.\n"
  	"	parents := method(\n"
  	"		deprecatedWarning(\"ancestorDirectories\")\n"
  	"		ancestorDirectories\n"
  	"	)\n"
  	"	\n"
  	"	//doc Directory accessibleParents Deprecated. Replaced by accessibleAncestors.\n"
  	"	accessibleParents := method(\n"
  	"		deprecatedWarning(\"accessibleAncestors\")\n"
  	"		accessibleAncestors\n"
  	"	)\n"
  	"	\n"
  	"	//doc Directory files Returns a list of File objects for the files in the Directory (no directories).\n"
  	"	files := method(items select(type == \"File\"))\n"
  	"\n"
  	"	//doc Directory fileNames Returns a list of strings for the names of the files (no subdirectories) in the directory.\n"
  	"	fileNames := method(files mapInPlace(name))\n"
  	"\n"
  	"	//doc Directory fileNamed(aName) Returns a File object for the specified file name whether it exists or not.\n"
  	"	fileNamed := method(name,\n"
  	"		//files detect(i, v, v name == name)\n"
  	"		File clone setPath(Path with(path, name))\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory filesWithExtension(aString) Returns a list of File objects for the files in the Directory (no directories) with the specified file extension.\n"
  	"	filesWithExtension := method(ext,\n"
  	"		if(ext containsSeq(\".\") not, ext = \".\" .. ext)\n"
  	"		files select(f, f name endsWithSeq(ext))\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory directoryNamed(aName) Returns a Directory object for the specified file name whether or not it exists.\n"
  	"	directoryNamed := method(name,\n"
  	"		Directory with(Path with(path, name))\n"
  	"		//directories detect(i, v, v name == name)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Directory folderNamed(aName) Deprecated. Replaced by directoryNamed().\n"
  	"	folderNamed := method(name,\n"
  	"		deprecatedWarning(\"directoryNamed(name)\")\n"
  	"		directoryNamed(name)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Directory remove Removes the directory.\n"
  	"	remove := method(\n"
  	"		File clone setPath(self path) remove\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory folderNamedCreateIfAbsent(name) Deprecated. Returns a new Directory object in the directory with the specified name.\n"
  	"	folderNamedCreateIfAbsent := method(name,\n"
  	"		deprecatedWarning(\"directoryNamed(name) create\")\n"
  	"		f := folderNamed(name)\n"
  	"		if(f, return f)\n"
  	"		createSubdirectory(name)\n"
  	"		folderNamed(name)\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory createFileNamed(name) Deprecated. Returns a new file object in the directory with the specified name.\n"
  	"	createFileNamed := method(name,\n"
  	"		deprecatedWarning(\"fileNamed(name) create\")\n"
  	"		f := fileNamed(name)\n"
  	"		if(f, return f)\n"
  	"		return File clone setPath(Path with(path, name))\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory moveTo(aPath) Moves the directory to the specified path.\n"
  	"	moveTo := method(path,\n"
  	"		File with(self path) moveTo(path)\n"
  	"		self\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Directory.io");

	s = "DynLib do(\n"
  	"	init := method(\n"
  	"		self forward := method(\n"
  	"			self performWithArgList(\"call\", list(call message name, call message arguments map(x, self doMessage(x))) flatten)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "DynLib.io");

	s = "Object do(\n"
  	"  //doc Object ifError Does nothing, returns self.\n"
  	"	ifError := method(self)\n"
  	"	//doc Object returnIfError Does nothing, returns self.\n"
  	"	returnIfError := getSlot(\"ifError\")\n"
  	"	//doc Object raiseIfError Does nothing, returns self.\n"
  	"	raiseIfError  := getSlot(\"ifError\")\n"
  	"	//doc Object isError Returns false if not an error.\n"
  	"	isError := false\n"
  	")\n"
  	"\n"
  	"Error do(\n"
  	"  /*doc Error ifError(code) \n"
  	"  Evaluates code in the context of sender. Returns self.\n"
  	"  <br/>\n"
  	"  Another form is <tt>Error ifError(error, code)</tt>. \n"
  	"  Note: <tt>error</tt> slot is set in the context of sender, Locals object is not created!\n"
  	"  */\n"
  	"	ifError := method(\n"
  	"		if(call message arguments size == 1) then(\n"
  	"			call evalArgAt(0)\n"
  	"		) elseif(call message arguments size > 1) then(\n"
  	"			call sender setSlot(call message argAt(0) name, self)\n"
  	"			call evalArgAt(1)\n"
  	"		) else(\n"
  	"			Exception raise(\"ifError requires at least 1 argument\")\n"
  	"		)\n"
  	"		self\n"
  	"	) setPassStops(true)\n"
  	"	\n"
  	"	//doc Error returnIfError Returns self from the context of sender.\n"
  	"	returnIfError := method(\n"
  	"		call sender return(self)\n"
  	"	) setPassStops(true)\n"
  	"	\n"
  	"	//doc Error raiseIfError Raises exception.\n"
  	"	raiseIfError := method( //message,\n"
  	"		Exception raise(message)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Error with(message) Returns new error with message slot set.\n"
  	"	with := method(message,\n"
  	"		error := self clone\n"
  	"		error message := message\n"
  	"		error location := call message label .. \":\" .. call message lineNumber\n"
  	"		error\n"
  	"	)\n"
  	"\n"
  	"	withShow := method(s,\n"
  	"		writeln(\"ERROR: \", s)\n"
  	"		error := self clone\n"
  	"		error message := message\n"
  	"		error location := call message label .. \":\" .. call message lineNumber\n"
  	"		error\n"
  	"	)\n"
  	"		\n"
  	"	//doc Error isError Returns true.\n"
  	"	isError := true\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Error.io");

	s = "File do(\n"
  	"	//doc File with(aPath) Returns a new instance with the provided path.\n"
  	"	with := method(path, self clone setPath(path))\n"
  	"\n"
  	"	//doc File streamDestination The buffer object to be used for future stream operations. \n"
  	"	//doc File setStreamDestination(aBuffer) Set the buffer to be used for future stream operations. \n"
  	"	streamDestination ::= nil\n"
  	"	\n"
  	"	//doc File streamReadSize Size of stream buffer used for streaming operations\n"
  	"	streamReadSize := 65536\n"
  	"	\n"
  	"	//doc File startStreaming Begin streamed read to stream destination set by setStreamDestination(aBuffer).\n"
  	"	startStreaming := method(streamTo(streamDestination))\n"
  	"\n"
  	"	//doc File exitStatus System's close status (after file close).\n"
  	"  	exitStatus := nil\n"
  	"\n"
  	"	//doc File streamTo(aBuffer) Perform streamed reading to given buffer. The buffer will be appended with chunks of size streamReadSize until EOF. The final chunk may be less than streamReadSize.\n"
  	"	streamTo := method(streamDestination,\n"
  	"		b := Sequence clone\n"
  	"		self open\n"
  	"		while(isAtEnd not,\n"
  	"			b empty\n"
  	"			readToBufferLength(b, streamReadSize)\n"
  	"			streamDestination write(b)\n"
  	"			yield\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	//doc File streamToWithoutYielding(aBuffer) Perform streamed reading to given buffer without yielding between reads.\n"
  	"	streamToWithoutYielding := method(streamDestination,\n"
  	"		b := Sequence clone\n"
  	"		self open\n"
  	"		while(isAtEnd not,\n"
  	"			b empty\n"
  	"			readToBufferLength(b, streamReadSize)\n"
  	"			streamDestination write(b)\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	//doc File copyToPathWithoutYielding(destinationPath) Copies the file to the specified path without yielding.\n"
  	"	copyToPathWithoutYielding := method(dstPath,\n"
  	"		dst := File with(dstPath) open\n"
  	"		self open streamToWithoutYielding(dst)\n"
  	"		dst close\n"
  	"		self close\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	//doc File copyToPath(destinationPath) Copies the file to the specified path.\n"
  	"	copyToPath := method(dstPath,\n"
  	"		dst := File with(dstPath) open\n"
  	"		self open streamTo(dst)\n"
  	"		dst close\n"
  	"		self close\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	/*\n"
  	"	// doc File lockFile Deprecated. The .lock file used for File locking.\n"
  	"	lockFile := method(File clone setPath(path .. \".lock\"))\n"
  	"\n"
  	"	// doc File lock Creates a path.lock file if it does not exist. If it does exist, it waits for it be removed by the process that created it first. Returns self.\n"
  	"	lock := method(timeout,\n"
  	"		if(timeout == nil, timeout = 10)\n"
  	"		lockFile := lockFile\n"
  	"		waitTime := .1\n"
  	"		waited := 0\n"
  	"		// a bit of a hack - this isn't atomic\n"
  	"		while(lockFile exists,\n"
  	"			wait(waitTime)\n"
  	"			waited = waited + waitTime\n"
  	"			if(waited > timeout, Exception raise(\"unable to acquire lock on \" .. path))\n"
  	"		)\n"
  	"		lockFile open close\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	unlock := method(lockFile remove)\n"
  	"	*/\n"
  	"	\n"
  	"	//doc File setContents(aSeq) Replaces the contents for the file with aSeq. Returns self.\n"
  	"	setContents := method(d, self truncateToSize(0) open write(d) close; self)\n"
  	"	\n"
  	"	//doc File appendToContents(aSeq) Appends to the contents of the file with aSeq. Returns self.\n"
  	"	appendToContents := method(\n"
  	"		openForAppending\n"
  	"		call evalArgs foreach(seq,\n"
  	"			self write(seq) \n"
  	"		)\n"
  	"		close\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	//doc File readToEnd(chunkSize) Reads chunkSize bytes (4096 by default) at a time until end of file is reached.  Returns a sequence containing the bytes read from the file.\n"
  	"	readToEnd := method(chunkSize,\n"
  	"		if(chunkSize not, chunkSize = 4096)\n"
  	"		buffer := Sequence clone\n"
  	"		while(readToBufferLength(buffer, chunkSize) == chunkSize, nil)\n"
  	"		buffer\n"
  	"	)\n"
  	"	\n"
  	"	//doc File create Creates an empty file at the file's path. Returns self on success, nil on failure.\n"
  	"	create := method(\n"
  	"		if(open, close; self, nil)\n"
  	"	)\n"
  	"	\n"
  	"	//doc File baseName Returns File's name without an extension (returned Sequence consists of all characters up to final period [\".\"] character).\n"
  	"	baseName := method(\n"
  	"		name split(\".\") slice(0, -1) join(\".\")\n"
  	"	)\n"
  	"	\n"
  	"	//doc File thisSourceFile Returns a File representing the system file in which this Io code exists.\n"
  	"	thisSourceFile := method(\n"
  	"		File with(Path with(call message label))\n"
  	"	)\n"
  	"	\n"
  	"	//doc File containingDirectory Deprecated. See parentDirectory.\n"
  	"	containingDirectory := method(\n"
  	"		deprecatedWarning(\"parentDirectory\")\n"
  	"		parentDirectory\n"
  	"	)\n"
  	"	\n"
  	"	//doc File parentDirectory Returns a File for the directory that is the parent directory of this object's path. \n"
  	"	parentDirectory := method(\n"
  	"		Directory with(path pathComponent)\n"
  	"	)\n"
  	"	\n"
  	"	standardOutput := File standardOutput\n"
  	"	standardInput  := File standardInput\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"	//doc Sequence asFile Returns a new File object with the receiver as it's path.\n"
  	"	asFile := method(\n"
  	"		File with(self)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "File.io");

	s = "/*\n"
  	"http://www.quag.geek.nz/io/schwartzian/\n"
  	"\n"
  	"A decorate-sort-undecorate operation for Io\n"
  	"\n"
  	"Specify a key for each item, and control how the keys are compared.\n"
  	"\n"
  	"Io> Range\n"
  	"Io> 0 to(10) asList sortByKey(x, (-1)**x * x)\n"
  	"==> list(9, 7, 5, 3, 1, 0, 2, 4, 6, 8, 10)\n"
  	"\n"
  	"Io> Directory with(\".\") files sortKey(lastInfoChangeDate) sort map(name)\n"
  	"==> ... listing of directory sorted by date\n"
  	"\n"
  	"Two forms of sortKey are supported:\n"
  	"\n"
  	"	* files sortKey(lastInfoChangeDate)\n"
  	"	* files sortKey(file, file lastInfoChangeDate)\n"
  	"\n"
  	"Three forms of sort are supported:\n"
  	"\n"
  	"	* files sortKey(...) sort\n"
  	"	* files sortKey(...) sort(<)\n"
  	"	* files sortKey(...) sort(x, y, x < y)\n"
  	"*/\n"
  	"\n"
  	"List sortByKey := method(\n"
  	"	call delegateToMethod(self, \"sortKey\") sort\n"
  	")\n"
  	"\n"
  	"List sortKey := method(\n"
  	"	schwart := call activated SchwartzianList clone\n"
  	"	if(call argCount == 1,\n"
  	"		body := call argAt(0)\n"
  	"		foreach(value,\n"
  	"			ss := stopStatus(k := value doMessage(body, call sender))\n"
  	"			if(ss isReturn, ss return(k))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			schwart addPair(k, value)\n"
  	"		)\n"
  	"	,\n"
  	"		valueName := call argAt(0) name\n"
  	"		foreach(value,\n"
  	"			call sender setSlot(valueName, value)\n"
  	"			ss := stopStatus(k := call evalArgAt(1))\n"
  	"			if(ss isReturn, ss return(k))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			schwart addPair(k, value)\n"
  	"		)\n"
  	"	)\n"
  	"	schwart\n"
  	") do(\n"
  	"	SchwartzianList := Object clone do(\n"
  	"		newSlot(\"pairs\")\n"
  	"\n"
  	"		init := method(\n"
  	"			pairs = list\n"
  	"		)\n"
  	"\n"
  	"		SchwartzianPair := Object clone do(\n"
  	"			newSlot(\"key\")\n"
  	"			newSlot(\"value\")\n"
  	"\n"
  	"			asSimpleString := method(\n"
  	"				\"(\" .. key asSimpleString .. \": \" .. value asSimpleString .. \")\"\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		addPair := method(key, value,\n"
  	"			pairs append(SchwartzianPair clone setKey(key) setValue(value))\n"
  	"		)\n"
  	"\n"
  	"		sort := method(\n"
  	"			if(call argCount == 0,\n"
  	"				pairs sortBy(block(x, y, x key < y key))\n"
  	"			,\n"
  	"				if(call argCount == 1,\n"
  	"					opName := call argAt(0) name\n"
  	"					args := list(nil)\n"
  	"					pairs sortBy(\n"
  	"						block(x, y,\n"
  	"							x key performWithArgList(opName, args atPut(0, y key))\n"
  	"						)\n"
  	"					)\n"
  	"				,\n"
  	"					sortCall := call\n"
  	"					xName := sortCall argAt(0) name\n"
  	"					yName := sortCall argAt(1) name\n"
  	"					pairs sortBy(\n"
  	"						block(x, y,\n"
  	"							sortCall sender setSlot(xName, x key)\n"
  	"							sortCall sender setSlot(yName, y key)\n"
  	"							sortCall evalArgAt(2)\n"
  	"						)\n"
  	"					)\n"
  	"				)\n"
  	"			) mapInPlace(p, p value)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "List_schwartzian.io");

	s = "Map do(\n"
  	"	//doc Map with(key1, value1, key2, value2, ...) Returns a new map containing the given keys and values\n"
  	"	with := method(\n"
  	"		m := Map clone\n"
  	"		args := call message arguments \n"
  	"		for(i, 0, args size - 1, 2,\n"
  	"			m atPut(call evalArgAt(i), call evalArgAt(i+1))\n"
  	"		)\n"
  	"		m\n"
  	"	)\n"
  	"	\n"
  	"	//doc Map asJson Converts a Map to a string that represents contents in JSON-compilant form\n"
  	"	asJson := method(\n"
  	"		\"{\" .. self keys map(k, k asJson .. \":\" .. self at(k) asJson) join(\",\") .. \"}\"\n"
  	"	)\n"
  	"	\n"
  	"	//doc Map asList Converts a Map to a list of lists. Each element in the returned list will be a list of two elements: the key, and the value.\n"
  	"	asList := method(\n"
  	"		self keys map(k, list(k, self at(k)))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map map(key, value, message)\n"
  	"		Create a List of results of message applied to self's items in a random\n"
  	"		order.\n"
  	"	*/\n"
  	"	map := method(\n"
  	"		result := List clone\n"
  	"		key := call argAt(0)\n"
  	"		value := call argAt(1)\n"
  	"		body := call argAt(2)\n"
  	"		self foreach(k, v,\n"
  	"			call sender setSlot(key name, k)\n"
  	"			call sender setSlot(value name, v)\n"
  	"			ss := stopStatus(r := call sender doMessage(body))\n"
  	"			if(ss isReturn, call setStopStatus(ss); return getSlot(\"v\"))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			result append(getSlot(\"r\"))\n"
  	"		)\n"
  	"		result\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map select(optionalIndex, optionalValue, message)\n"
  	"		Create a new Map with keys,values of self for which message evaluated\n"
  	"		to non-nil.\n"
  	"	*/\n"
  	"	select := method(\n"
  	"		result := Map clone\n"
  	"		self keys foreach(key,\n"
  	"			if(call argCount > 1,\n"
  	"				call sender setSlot(call argAt(0) name, key)\n"
  	"				if(call argCount == 3,\n"
  	"					call sender setSlot(call argAt(1) name, self at(key))\n"
  	"				)\n"
  	"			)\n"
  	"			ss := stopStatus(v := call evalArgAt(call argCount - 1))\n"
  	"			if(ss isReturn, call setStopStatus(ss); return getSlot(\"v\"))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			if(getSlot(\"v\"),\n"
  	"				result atPut(key, self at(key))\n"
  	"			)\n"
  	"		)\n"
  	"		result\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map detect(optionalIndex, optionalValue, message)\n"
  	"		Returns a random value for which message evals to non-nil.\n"
  	"	*/\n"
  	"	detect := method(\n"
  	"		self keys foreach(key,\n"
  	"			if(call argCount > 1,\n"
  	"				call sender setSlot(call argAt(0) name, key)\n"
  	"				if(call argCount == 3,\n"
  	"					call sender setSlot(call argAt(1) name, self at(key))\n"
  	"				)\n"
  	"			)\n"
  	"			ss := stopStatus(v := call evalArgAt(call argCount - 1))\n"
  	"			if(ss isReturn, call setStopStatus(ss); return getSlot(\"v\"))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			if(getSlot(\"v\"),\n"
  	"				return list(key, self at(key))\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	/*doc Map merge(anotherMap)\n"
  	"		Returns a new map created by merging the pairs from anotherMap into this map\n"
  	"	*/\n"
  	"	merge := method(anotherMap,\n"
  	"		self clone mergeInPlace(anotherMap)\n"
  	"	)\n"
  	"	\n"
  	"	/*doc Map mergeInPlace(anotherMap)\n"
  	"		Merges the pairs from anotherMap into this map\n"
  	"	*/\n"
  	"	mergeInPlace := method(anotherMap,\n"
  	"		addKeysAndValues(anotherMap keys, anotherMap values)\n"
  	"	)\n"
  	"\n"
  	"	//doc Map reverseMap Create a new Map using values as keys and keys as values\n"
  	"	reverseMap := method(\n"
  	"		Map clone addKeysAndValues(values, keys)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Map asObject Create a new Object whose slotDescriptionMap will be equal to self\n"
  	"	asObject := method(\n"
  	"		o := Object clone\n"
  	"		self foreach(k, v, o setSlot(k, getSlot(\"v\")))\n"
  	"		o\n"
  	"	)\n"
  	"	\n"
  	"	//doc Map isEmpty returns true if this map doesn't contain any pairs.\n"
  	"	isEmpty := method(\n"
  	"		keys isEmpty\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Map.io");

	s = "Message do(\n"
  	"	/*doc Message union(other) Creates a union of the receiver and the other parameter. \n"
  	"	Returns a new message object with the receivers message as the first argument of the returned message, \n"
  	"	and the other parameter's arguments as each successive argument to the new message.\n"
  	"	<br/>\n"
  	"	<pre>\n"
  	"  Io> message(a) union(message(b))\n"
  	"  ==> [unnamed](a, b)\n"
  	"  </pre>\n"
  	"	*/\n"
  	"	union := method(\n"
  	"		r := Message clone\n"
  	"		l := list(self)\n"
  	"		call message argAt(0) arguments foreach(arg, l append(arg))\n"
  	"		r setArguments(l)\n"
  	"	)\n"
  	"	\n"
  	"  //doc Message asSimpleString Returns one-line string representation up to 40 characters long.\n"
  	"	asSimpleString := method(\n"
  	"		s := self asString asMutable replaceSeq(\" ;\\n\", \"; \")\n"
  	"		if(s size > 40,\n"
  	"			s exclusiveSlice(0, 37) .. \"...\"\n"
  	"		,\n"
  	"			s\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Message.io");

	s = "Number do(\n"
  	"	//doc Number isInASequenceSet Return true if receiver is in one of the Sequence sequenceSets, otherwise false.\n"
  	"	isInASequenceSet := method(\n"
  	"		Sequence sequenceSets foreach(set,\n"
  	"			if(in(set), return true)\n"
  	"		)\n"
  	"		false\n"
  	"	)\n"
  	"\n"
  	"	//doc Number constants Object containing number constants e, inf, nan and pi.\n"
  	"\n"
  	"	constants := Object clone do(\n"
  	"		//doc Number nan Returns a infinity constant.\n"
  	"		nan := 0/0\n"
  	"\n"
  	"		//doc Number inf Returns a not-a-number constant.\n"
  	"		inf := 1/0\n"
  	"\n"
  	"		//doc Number e Returns the constant e.\n"
  	"		e  := 2.71828182845904523536028747135266249\n"
  	"\n"
  	"		//doc Number pi Returns the constant pi.\n"
  	"		pi := 3.14159265358979323846264338327950288\n"
  	"	)\n"
  	"\n"
  	"	asSimpleString := method(self asString)\n"
  	"\n"
  	"	//doc Number toBase(base) Returns the number in another base. 42 toBase(2) -> \"101010\"\n"
  	"	toBase := method(base, self asString toBase(base))\n"
  	"\n"
  	"        //doc Number toBaseWholeBytes(base) Returns the number in another base printing out entire bytes. 42 toBaseWholeBytes(2) -> \"00101010\"\n"
  	"        toBaseWholeBytes := method(base,\n"
  	"            str := self asString toBase(base)\n"
  	"            byteColumns := 256 log(base) ceil\n"
  	"            alignedWidth := (str size / byteColumns) ceil * byteColumns\n"
  	"            str alignRight(alignedWidth, \"0\")\n"
  	"        )\n"
  	"\n"
  	"	//doc Number asHex Returns the number as hex digits inside a string. 97 asHex -> \"61\"\n"
  	"	asHex := method(toBaseWholeBytes(16))\n"
  	"\n"
  	"	//doc Number asBinary Returns the number as binary digits inside a string. 42 asBinary -> \"101010\"\n"
  	"	asBinary := method(toBaseWholeBytes(2))\n"
  	"\n"
  	"	//doc Number asOctal Returns the number as octal digits inside a string. 436 asOctal -> \"664\"\n"
  	"	asOctal := method(toBaseWholeBytes(8))\n"
  	"\n"
  	"	//doc Number combinations(size) Returns the combinations where the receiver is the number of different objects and size is the number to be arranged.\n"
  	"	combinations := method(r, self factorial /(r factorial *((self - r) factorial)))\n"
  	"\n"
  	"	//doc Number permutations(size) Returns the permutations where the receiver is the number of different objects and size is the number to be arranged.\n"
  	"	permutations := method(r, self factorial /((self - r) factorial))\n"
  	"\n"
  	"	//doc Number minMax(low, high) Returns a number between or equal to low and high. If the receiver is equal to or between low and high, the reciever is returned. If the reciever is less than low, low is returned. If the receiver is greater than high, high is returned.\n"
  	"	minMax := method(low, high, min(high) max(low))\n"
  	"	\n"
  	"	asJson := getSlot(\"asString\")\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Number.io");

	s = "Block printProfile := method(\n"
  	"	m := getSlot(\"self\") message\n"
  	"	writeln(\"  \", getSlot(\"self\") profilerTime asString(0,6), \"s in Block (\", getSlot(\"self\") argumentNames join(\",\"), \") \", m label, \" \", m lineNumber)\n"
  	")\n"
  	"\n"
  	"Core getSlot(\"CFunction\") printProfile := method(\n"
  	"	writeln(\"  \", getSlot(\"self\") profilerTime asString(0,6), \"s in CFunction \", getSlot(\"self\") uniqueName, \"()\")\n"
  	"	\n"
  	")\n"
  	"\n"
  	"Profiler do(\n"
  	"	start := method(\n"
  	"		self reset\n"
  	"		Block setProfilerOn(true)\n"
  	"		//CFunction setProfilerOn(true)\n"
  	"		Core getSlot(\"CFunction\") setProfilerOn(true)\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	stop := method(\n"
  	"		Block setProfilerOn(false)\n"
  	"		//CFunction setProfilerOn(false)\n"
  	"		Core getSlot(\"CFunction\") setProfilerOn(false)\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	show := method(\n"
  	"		writeln(\"\\nProfile:\")\n"
  	"		blocks := self timedObjects select(b, getSlot(\"b\") type == \"Block\") // or getSlot(\"b\") type == \"CFunction\")\n"
  	"		blocks := blocks map(b, \n"
  	"			o := Object clone\n"
  	"			o newSlot(\"b\", getSlot(\"b\"))\n"
  	"			o newSlot(\"profilerTime\", getSlot(\"b\") profilerTime) \n"
  	"			o\n"
  	"		) \n"
  	"		blocks := blocks sortByKey(profilerTime) reverse select(profilerTime > 0)\n"
  	"		if(blocks size == 0, \n"
  	"			writeln(\"  sample size to small\")\n"
  	"		,\n"
  	"			maxTime := blocks first profilerTime\n"
  	"			blocks foreach(b,\n"
  	"				b getSlot(\"b\") printProfile\n"
  	"				if(b profilerTime < maxTime/100, break)\n"
  	"			)\n"
  	"		)\n"
  	"		writeln(\"\")\n"
  	"	)\n"
  	"	\n"
  	"	profile := method(\n"
  	"		start\n"
  	"		call evalArgAt(0)\n"
  	"		stop\n"
  	"		show\n"
  	"	)\n"
  	"	\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Profiler.io");

	s = "Sandbox do(\n"
  	"	//doc Sandbox printCallback(string) default implementation is; method(string, string print)\n"
  	"	printCallback := method(string, string print)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Sandbox.io");

	s = "\n"
  	"//doc nil justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"//doc true justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"//doc false justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"\n"
  	"nil   justSerialized := method(stream, stream write(\"nil\"))\n"
  	"true  justSerialized := method(stream, stream write(\"true\"))\n"
  	"false justSerialized := method(stream, stream write(\"false\"))\n"
  	"\n"
  	"//doc Number justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Number justSerialized := method(stream,\n"
  	"	stream write(self asSimpleString)\n"
  	")\n"
  	"\n"
  	"//doc Sequence justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Sequence justSerialized := method(stream,\n"
  	"	stream write(self asMutable escape asSimpleString)\n"
  	")\n"
  	"\n"
  	"//doc List justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"List justSerialized := method(stream,\n"
  	"	stream write(\"list(\")\n"
  	"	stream write(self map(serialized) join(\", \"))\n"
  	"	stream write(\");\")\n"
  	")\n"
  	"\n"
  	"//doc Map justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Map justSerialized := method(stream,\n"
  	"	stream write(\"Map clone do(\")\n"
  	"	self foreach(k, v,\n"
  	"		stream write(\"atPut(\" .. k serialized .. \", \" .. getSlot(\"v\") serialized .. \");\")\n"
  	"	)\n"
  	"	stream write(\");\")\n"
  	")\n"
  	"\n"
  	"//doc Block justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Block justSerialized := method(stream,\n"
  	"		stream write(code, \"\\n\")\n"
  	")\n"
  	"\n"
  	"SerializationStream := Object clone do(\n"
  	"	init := method(\n"
  	"		self seen := Map clone\n"
  	"		self output := Sequence clone\n"
  	"	)\n"
  	"\n"
  	"	write := method(\n"
  	"		for(i, 0, call argCount - 1,\n"
  	"			//super(writeln(i, call argAt(i)))\n"
  	"			output appendSeq(call evalArgAt(i))\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"  /*doc Object serialized\n"
  	"  Returns a serialized representation of the receiver.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> Object clone do(x:=1) serialized\n"
  	"  ==> Object clone do(\n"
  	"  	x := 1\n"
  	"  )\n"
  	"  </pre>\n"
  	"  */\n"
  	"	serialized := method(stream,\n"
  	"		if(stream == nil, stream := SerializationStream clone)\n"
  	"		justSerialized(stream)\n"
  	"		stream output\n"
  	"	)\n"
  	"  \n"
  	"  /*doc Object justSerialized(stream)\n"
  	"  Writes serialized representation to a SerializationStream. Returns stream contents. \n"
  	"  [This is unintended side effect! Returned value may change in the future.]\n"
  	"  */\n"
  	"	justSerialized := method(stream,\n"
  	"		stream write(getSlot(\"self\") type, \" clone do(\\n\")\n"
  	"		self serializedSlots(stream)\n"
  	"		stream write(\")\\n\")\n"
  	"	)\n"
  	"\n"
  	"  //doc Object serializedSlots(stream) Writes all slots to a stream.\n"
  	"	serializedSlots := method(stream,\n"
  	"		self serializedSlotsWithNames(self slotNames, stream)\n"
  	"	)\n"
  	"\n"
  	"  //doc Object serializedSlotsWithNames(names, stream) Writes selected slots to a stream.\n"
  	"	serializedSlotsWithNames := method(names, stream,\n"
  	"		names foreach(slotName,\n"
  	"			stream write(\"\\t\", slotName, \" := \")\n"
  	"			self getSlot(slotName) serialized(stream)\n"
  	"			stream write(\"\\n\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Serialize.io");

	s = "System do(\n"
  	"	args := list()\n"
  	"	\n"
  	"	launchScript := nil\n"
  	"	//doc System launchScript Returns the path of the io file run on the command line. Returns nil if no file was run.\n"
  	"\n"
  	"	ioPath := installPrefix asMutable appendPathSeq(\"lib\") appendPathSeq(\"io\")\n"
  	"	//doc System ioPath Returns the path of io installation. The default is $INSTALL_PREFIX/lib/io.\n"
  	"\n"
  	"	/*doc System getOptions(args) \n"
  	"	This primitive is used to get command line options similar to Cs getopt().\n"
  	"	It returns a map in containing the left side of the argument, with the\n"
  	"	value of the right side. (The key will not contain\n"
  	"	the beginning dashes (--).\n"
  	"	<p>\n"
  	"	Example:\n"
  	"	<pre>\n"
  	"	options := System getOptions(args)\n"
  	"	options foreach(k, v,\n"
  	"	  if(v type == List type,\n"
  	"		v foreach(i, j, writeln(\\\"Got unnamed argument with value: \\\" .. j))\n"
  	"		continue\n"
  	"	  )\n"
  	"	  writeln(\\\"Got option: \\\" .. k .. \\\" with value: \\\" .. v)\n"
  	"	)\n"
  	"	</pre>\n"
  	"	*/\n"
  	"\n"
  	"	getOptions := method(arguments,\n"
  	"		opts := Map clone\n"
  	"		optname := Sequence clone\n"
  	"		optvalue := Sequence clone\n"
  	"		optsNoKey := List clone\n"
  	"\n"
  	"		arguments foreach(i, arg,\n"
  	"			if(arg beginsWithSeq(\"--\") isNil,\n"
  	"				optsNoKey append(arg)\n"
  	"				continue\n"
  	"			)\n"
  	"\n"
  	"			if(arg containsSeq(\"=\")) then(\n"
  	"				optname := arg clone asMutable\n"
  	"				optname clipAfterStartOfSeq(\"=\")\n"
  	"				optname clipBeforeEndOfSeq(\"--\")\n"
  	"				optvalue := arg clone asMutable\n"
  	"				optvalue clipBeforeEndOfSeq(\"=\")\n"
  	"			) else(\n"
  	"				optname := arg clone asMutable\n"
  	"				optname clipBeforeEndOfSeq(\"--\")\n"
  	"				optvalue = \"\"\n"
  	"			)\n"
  	"			opts atPut(optname, optvalue)\n"
  	"		)\n"
  	"\n"
  	"		if(optsNoKey last != nil, opts atPut(\"\", optsNoKey))\n"
  	"		opts\n"
  	"	)\n"
  	"\n"
  	"	//doc System userInterruptHandler Called when control-c is hit. Override to add custom behavior. Returns self.\n"
  	"	userInterruptHandler := method(\n"
  	"		writeln(\"\\n  current coroutine\")\n"
  	"		Scheduler currentCoroutine showStack\n"
  	"		Scheduler yieldingCoros foreach(coro,\n"
  	"			writeln(\"  coroutine \", coro label)\n"
  	"			coro showStack\n"
  	"		)\n"
  	"		self exit\n"
  	"	)\n"
  	"	\n"
  	"	//doc System runCommand Calls system and redirects stdout/err to tmp files.  Returns object with exitStatus, stdout and stderr slots.\n"
  	"	runCommand := method(cmd, successStatus,\n"
  	"		successStatus := if(successStatus, successStatus, 0)\n"
  	"		tmpDirPath := System getEnvironmentVariable(\"TMPDIR\")\n"
  	"		outPath := method(suffix,\n"
  	"			Path with(tmpDirPath, list(System thisProcessPid, Date clone now asNumber, suffix) join(\"-\"))\n"
  	"		)\n"
  	"		stdoutPath := outPath(\"stdout\")\n"
  	"		stderrPath := outPath(\"stderr\")\n"
  	"		exitStatus := System system(cmd .. \" > \" .. stdoutPath .. \" 2> \" .. stderrPath)\n"
  	"		result := Object clone\n"
  	"		result successStatus := successStatus\n"
  	"		result exitStatus := exitStatus\n"
  	"		result failed := method(exitStatus != successStatus)\n"
  	"		result succeeded := method(exitStatus == successStatus)\n"
  	"		result stdout := File with(stdoutPath) contents\n"
  	"		result stderr := File with(stderrPath) contents\n"
  	"		result\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "System.io");

	s = "//metadoc UnitTest category Test\n"
  	"/*metadoc UnitTest description\n"
  	"An object for organizing and running unit tests validated by assertions.\n"
  	"*/\n"
  	"\n"
  	"//doc UnitTest setUp Method called prior to each test.\n"
  	"//doc UnitTest tearDown Method called after each test.\n"
  	"//doc UnitTest testCount Returns the number of tests defined in this object.\n"
  	"//doc UnitTest run Runs all tests.\n"
  	"//doc UnitTest fail Call to trigger a test failure.\n"
  	"UnitTest := Object clone do(\n"
  	"	verbose := method(s,\n"
  	"		//nil\n"
  	"		writeln(s)\n"
  	"	)\n"
  	"\n"
  	"	setUp := method(nil)\n"
  	"	\n"
  	"	tearDown := method(nil)\n"
  	"	init := method(self exceptions := List clone)\n"
  	"	testSlotNames := method(\n"
  	"		names := self slotNames select(name, name beginsWithSeq(\"test\")) \n"
  	"		if(names isEmpty, names, names sortByKey(name, self getSlot(name) message lineNumber))\n"
  	"	)\n"
  	"	\n"
  	"	testCount := method(testSlotNames size)\n"
  	"\n"
  	"	run := method(\n"
  	"		testSlotNames foreach(n,\n"
  	"			self setUp\n"
  	"			verbose(\"    \" .. n)\n"
  	"			e := try(stopStatus(self doString(n)))\n"
  	"			if(e,\n"
  	"				write(\"    \", n, \" - failed\")\n"
  	"				exceptions append(e)\n"
  	"				write(\"\\n\")\n"
  	"				writeln(e showStack)\n"
  	"				//System exit\n"
  	"			)\n"
  	"			//Scheduler currentCoroutine yield\n"
  	"			self tearDown\n"
  	"			//Collector collect\n"
  	"		)\n"
  	"		self ?cleanUp\n"
  	"	)\n"
  	"\n"
  	"	fail := method(Exception raise(\"fail\"))\n"
  	"\n"
  	"//doc UnitTest assertEquals(a, b) Fail the running test if a != b.\n"
  	"//doc UnitTest assertNotEquals(a, b) Fail the running test if a == b.\n"
  	"//doc UnitTest assertNotSame(a, b) Fail the running test if a != b.\n"
  	"//doc UnitTest assertNil(a) Fail the running test if a != nil.\n"
  	"//doc UnitTest assertNotNil(a) Fail the running test if a == nil.\n"
  	"//doc UnitTest assertTrue(a) Fail the running test if a != true.\n"
  	"//doc UnitTest assertFalse(a) Fail the running test if a != false.\n"
  	"//doc UnitTest assertRaisesException(code) Fail the running test if the code does not raise an Exception.\n"
  	"/*doc UnitTest assertEqualsWithinDelta(expected, actual, delta)\n"
  	"Fail the running test if the expected value is not within delta of the actual value.\n"
  	"*/\n"
  	"\n"
  	"	assertEquals := method(a, b, m,\n"
  	"		//writeln(\"assertEquals1 call message = \", call message type)\n"
  	"		mm := call message\n"
  	"		if(m == nil, m = mm)\n"
  	"		d := m argAt(0) code .. \" != \" .. call argAt(1) code\n"
  	"		if(a != b, Exception raise(\"[\" .. d .. \"] [\" .. a asSimpleString .. \" != \" .. b asSimpleString .. \"]\"))\n"
  	"		//writeln(\"assertEquals2\")\n"
  	"	)\n"
  	"\n"
  	"	assertNotEquals := method(a, b, if(a == b, Exception raise(a asSimpleString .. \" == \" .. b asSimpleString)))\n"
  	"\n"
  	"	assertSame    := method(a, b, assertEquals(a uniqueId, b uniqueId, call message))\n"
  	"	assertNotSame := method(a, b, assertNotEquals(a uniqueId, b uniqueId, call message))\n"
  	"	assertNil     := method(a, assertEquals(a, nil, call message))\n"
  	"	assertNotNil  := method(a, assertNotEquals(a, nil, call message))\n"
  	"	assertTrue    := method(a, assertEquals(a, true, call message))\n"
  	"	assertFalse   := method(a, assertEquals(a, false, call message))\n"
  	"\n"
  	"	assertRaisesException := method(\n"
  	"		e := try(\n"
  	"			stopStatus(call evalArgAt(0))\n"
  	"			writeln(\"Should have raised Exception\")\n"
  	"		)\n"
  	"		e ifNil(Exception raise(\"Should have raised Exception\"))\n"
  	"	)\n"
  	"\n"
  	"	knownBug := method(\n"
  	"		//writeln(\"  [known bug: \", call argAt(0) code, \"]\")\n"
  	"	)\n"
  	"\n"
  	"	assertEqualsWithinDelta := method(expected, actual, delta,\n"
  	"		if(((expected - actual) abs > delta),\n"
  	"			Exception raise(\"expected \" .. expected .. \" but was \" .. actual .. \" (allowed delta: \" .. delta .. \")\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"//metadoc TestSuite category Testing\n"
  	"/*metadoc TestSuite description\n"
  	"An object to collect and run multiple UnitTests defined in *Test.io files within the System launchPath directory.\n"
  	"*/\n"
  	"TestSuite := Object clone do(\n"
  	"	verbose := method(s,\n"
  	"		nil\n"
  	"		//writeln(s)\n"
  	"	)\n"
  	"\n"
  	"//doc TestSuite name Return the name of the TestSuite.\n"
  	"	name := method(\n"
  	"		path asMutable pathComponent lastPathComponent\n"
  	"	)\n"
  	"\n"
  	"	path ::= \".\"\n"
  	"\n"
  	"/*doc TestSuite run\n"
  	"Collects and all files named *Test.io within the System launchPath directory,\n"
  	"runs their tests and prints collated results.\n"
  	"*/\n"
  	"	run := method(\n"
  	"		verbose(\"\\n\" .. name)\n"
  	"		unitTestFiles := Directory with(System launchPath) files select(f, f name endsWithSeq(\"Test.io\"))\n"
  	"		exceptions := List clone\n"
  	"		testCount := 0\n"
  	"\n"
  	"		unitTestFiles foreach(f,\n"
  	"			1 repeat(\n"
  	"				verbose(\"  \" .. f name fileName)\n"
  	"				test := Lobby doString(f contents, f path)\n"
  	"				//Collector collect\n"
  	"				test run\n"
  	"			)\n"
  	"			testCount = testCount + test testCount\n"
  	"			exceptions appendSeq(test exceptions)\n"
  	"		)\n"
  	"\n"
  	"		verbose(\"  ---------------\")\n"
  	"		//Collector collect\n"
  	"		//if(testCount == 0, write(\"(no tests)\"); File standardOutput flush; return(0))\n"
  	"		if(exceptions size > 0) then(\n"
  	"			//writeln(\"	FAILED \", testCount, \" tests, \", exceptions size, \" failures\\n\")\n"
  	"			return(exceptions size)\n"
  	"		) else(\n"
  	"			//writeln(\"	PASSED \", testCount, \" tests\\n\")\n"
  	"			return(0)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "UnitTest.io");

	s = "Sequence do(\n"
  	"	x := method(at(0))\n"
  	"	y := method(at(1))\n"
  	"	z := method(at(2))\n"
  	"	setX := method(a, atPut(0, a); self)\n"
  	"	setY := method(a, atPut(1, a); self)\n"
  	"	setZ := method(a, atPut(2, a); self)\n"
  	"	set := method(call evalArgs foreach(i, v, atPut(i, v)))\n"
  	"	rootMeanSquare := method(meanSquare sqrt)\n"
  	")\n"
  	"\n"
  	"Sequence addEquals := Sequence getSlot(\"+=\")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Vector.io");

	s = "Path := Object clone do(\n"
  	"	//metadoc Path category FileSystem\n"
  	"\n"
  	"	//doc Path hasDriveLetters returns true if the platform requires DOS C: style drive letters.\n"
  	"	hasDriveLetters := System platform containsAnyCaseSeq(\"Windows\") or System platform containsAnyCaseSeq(\"Cygwin\")\n"
  	"\n"
  	"	//doc Path with(aSequence) Returns a new Path object for the given Sequence.\n"
  	"	with := method(\n"
  	"		s := Sequence clone\n"
  	"		call message arguments foreach(arg,\n"
  	"			v := call sender doMessage(arg)\n"
  	"			//writeln(\"appendPathSeq(\", v type, \")\")\n"
  	"			if(v != nil, \n"
  	"				s appendPathSeq(v)\n"
  	"			)\n"
  	"		)\n"
  	"		s asSymbol\n"
  	"	)\n"
  	"\n"
  	"	//doc Path isPathAbsolute Returns true if path is absolute, false if it is relative.\n"
  	"	isPathAbsolute := method(p,\n"
  	"		if(p == nil or p size == 0, return false)\n"
  	"		\n"
  	"		absolute := false\n"
  	"		//try (\n"
  	"			if (hasDriveLetters,\n"
  	"				absolute = p at(0) isLetter and p at(1) asCharacter == \":\" or p at(0) asCharacter == \"/\" or p at(0) asCharacter == \"\\\\\"\n"
  	"			,\n"
  	"				absolute = p at(0) asCharacter == \"/\"\n"
  	"			)\n"
  	"		//)\n"
  	"		absolute\n"
  	"	)\n"
  	"\n"
  	"	//doc Path absolute Returns an absolute version of the path.\n"
  	"	absolute := method(path,\n"
  	"		if(isPathAbsolute(path),\n"
  	"			path\n"
  	"		,\n"
  	"			with(Directory currentWorkingDirectory, path)\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Path thisSourceFilePath Uses call message label to return an absolute path to the file that contains the sender.\n"
  	"	thisSourceFilePath := method(\n"
  	"		Path absolute(call message label)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Y_Path.io");

	s = "CLI := Object clone do(\n"
  	"	prompt ::= \"Io> \"\n"
  	"	outPrompt ::= \"==> \"\n"
  	"	continuedLinePrompt ::= \"    \"\n"
  	"\n"
  	"	context ::= method(Lobby)\n"
  	"	isRunning ::= true\n"
  	"\n"
  	"	commandLineLabel ::= \"Command Line\"\n"
  	"\n"
  	"	lineReader ::= nil\n"
  	"\n"
  	"	stop := method(setIsRunning(false))\n"
  	"\n"
  	"	runFile := method(path,\n"
  	"		System launchPath := if(Path isPathAbsolute(path),\n"
  	"			path\n"
  	"		,\n"
  	"			Directory currentWorkingDirectory asMutable appendPathSeq(path)\n"
  	"		) pathComponent\n"
  	"\n"
  	"		System launchScript = path\n"
  	"\n"
  	"		e := try(context doFile(path)) \n"
  	"		if(e, e showStack; return -1)\n"
  	"		return 0\n"
  	"	)\n"
  	"\n"
  	"	runIorc := method(\n"
  	"		home := System getEnvironmentVariable(\"HOME\")\n"
  	"		if(home,\n"
  	"			path := Path with(home, \".iorc\")\n"
  	"			if(File with(path) exists,\n"
  	"				context doFile(path)\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	ioHistoryFile := method(\n"
  	"		Path with(System getEnvironmentVariable(\"HOME\"), \".io_history\")\n"
  	"	)\n"
  	"\n"
  	"	saveHistory := method(\n"
  	"		lineReader ?saveHistory(ioHistoryFile)\n"
  	"	)\n"
  	"\n"
  	"	loadHistory := method(\n"
  	"		if(File with(ioHistoryFile) exists,\n"
  	"			lineReader ?loadHistory(ioHistoryFile)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	run := method(		\n"
  	"		System launchPath := Directory currentWorkingDirectory\n"
  	"		Importer addSearchPath(System launchPath)\n"
  	"		context exit := method(\n"
  	"			CLI saveHistory\n"
  	"			System exit\n"
  	"		)\n"
  	"		\n"
  	"		runIorc\n"
  	"\n"
  	"		if(System ?args first == \"-e\",\n"
  	"			writeln(context doString(System args exSlice(1) map(asUTF8) join(\" \")))\n"
  	"			return\n"
  	"		)\n"
  	"\n"
  	"		if(System ?args and System args size > 0,\n"
  	"\n"
  	"			if(System args first == \"-i\",\n"
  	"				if(System args size >= 2,\n"
  	"					return runFile(System args at(1))\n"
  	"				,\n"
  	"					if(File clone setPath(\"main.io\") exists, runFile(\"main.io\"))\n"
  	"				)\n"
  	"				return interactiveMultiline\n"
  	"			)\n"
  	"\n"
  	"			runFile(System args first)\n"
  	"		,\n"
  	"			if(File clone setPath(\"main.io\") exists,\n"
  	"				runFile(\"main.io\")\n"
  	"			,\n"
  	"				interactiveMultiline\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	writeWelcomeBanner := method(\n"
  	"		writeln(\"Io \", System version)\n"
  	"	)\n"
  	"\n"
  	"	interactiveMultiline := method(\n"
  	"		writeWelcomeBanner\n"
  	"\n"
  	"		// Use GNU Readline as the default line reader. Fall back to Editline \n"
  	"		//try(setLineReader(ReadLine))\n"
  	"		//try(lineReader ifNil( setLineReader(EditLine)))\n"
  	"\n"
  	"		//loadHistory // don't inable this unless you intend to make it work properly on osx\n"
  	"\n"
  	"		while(isRunning,\n"
  	"			if(lineReader isNil not,\n"
  	"				handleInteractiveMultiline\n"
  	"			,\n"
  	"				interactiveNoLineReader\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		//saveHistory\n"
  	"	)\n"
  	"\n"
  	"	interactive := method(\n"
  	"		writeWelcomeBanner\n"
  	"		while(isRunning,\n"
  	"			handleInteractiveSingleLine\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	writeCommandResult := method(result,\n"
  	"		e := try(string := getSlot(\"result\") asString)\n"
  	"		if(e not,\n"
  	"			writeln(outPrompt, string)\n"
  	"		,\n"
  	"			writeln(outPrompt, \"<exception while dislaying result>\")\n"
  	"			e showStack\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	/*\n"
  	"	handleInteractiveSingleLine := method(\n"
  	"		line := EditLine readLine(prompt)\n"
  	"		line ifNil(\n"
  	"			writeln\n"
  	"			context exit\n"
  	"		)\n"
  	"\n"
  	"		EditLine addHistory(line)\n"
  	"\n"
  	"		e := try(result := context doMessage(line asMessage(commandLineLabel)))\n"
  	"		if(e,\n"
  	"			e showStack\n"
  	"		,\n"
  	"			writeCommandResult(getSlot(\"result\"))\n"
  	"		)\n"
  	"	)\n"
  	"	*/\n"
  	"\n"
  	"	interactiveNoLineReader := method(\n"
  	"		write(prompt)\n"
  	"		File standardOutput flush\n"
  	"\n"
  	"		line := File standardInput readLine\n"
  	"\n"
  	"		line ifNil(\n"
  	"			writeln\n"
  	"			context exit\n"
  	"		)\n"
  	"\n"
  	"		e := try(result := context doMessage(line asMessage(commandLineLabel)))\n"
  	"		if(e,\n"
  	"			e showStack\n"
  	"		,\n"
  	"			writeCommandResult(getSlot(\"result\"))\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	errorMessage := method(error,\n"
  	"		error beforeSeq(\" on line\")\n"
  	"	)\n"
  	"\n"
  	"	# Find error messages for the errors we understand\n"
  	"	lazySlot(\"knownErrors\",\n"
  	"		m := Map clone\n"
  	"		m atPut(compileErrorMessage(\"(\"), \")-> \")\n"
  	"		m atPut(compileErrorMessage(\"[\"), \"]-> \")\n"
  	"		m atPut(compileErrorMessage(\"{\"), \"}-> \")\n"
  	"		m atPut(compileErrorMessage(\"\\\"\\\"\\\"\"), \"\\\"-> \")\n"
  	"		m atPut(knownErrorMissingArgument, \")-> \")\n"
  	"	)\n"
  	"\n"
  	"	lazySlot(\"knownErrorMissingArgument\",\n"
  	"		compileErrorMessage(\"(x,\")\n"
  	"	)\n"
  	"\n"
  	"	compileErrorMessage := method(source,\n"
  	"		errorMessage(try(source asMessage) error)\n"
  	"	)\n"
  	"\n"
  	"	handleInteractiveMultiline := method(\n"
  	"		# Start with the default prompt. The prompt is changed for continued lines, and errors.\n"
  	"		nextPrompt := prompt\n"
  	"		line := \"\"\n"
  	"\n"
  	"		# If there are unmatched ( or the command ends with a \\ then we'll need to read multiple lines\n"
  	"		loop(\n"
  	"			# Write out prompt and read line\n"
  	"			nextLine := lineReader readLine(nextPrompt)\n"
  	"\n"
  	"			# If there was no line, exit\n"
  	"			nextLine ifNil(context exit)\n"
  	"\n"
  	"			# Add what we read to the line we've been building up\n"
  	"			if(nextLine size > 0,\n"
  	"				if(line size > 0,\n"
  	"					line = line .. nextLine\n"
  	"				,\n"
  	"					line = nextLine\n"
  	"				)\n"
  	"			)\n"
  	"\n"
  	"			# If there is a \\ on the end of the line, then keep building up the line\n"
  	"			if(line endsWithSeq(\"\"\"\\\\\"\"\"),\n"
  	"				nextPrompt = continuedLinePrompt\n"
  	"				continue\n"
  	"			)\n"
  	"\n"
  	"			compileError := try(lineAsMessage := line asMessage(commandLineLabel))\n"
  	"			if(compileError,\n"
  	"				if(nextLine size > 0,\n"
  	"					# If they're missing the end of the line, then let them finish it\n"
  	"					error := compileError error\n"
  	"					continuePrompt := knownErrors at(errorMessage(error))\n"
  	"					if(error == knownErrorMissingArgument and line asMutable strip endsWithSeq(\",\") not,\n"
  	"						continuePrompt = nil\n"
  	"					)\n"
  	"					if(continuePrompt,\n"
  	"						nextPrompt = continuePrompt\n"
  	"						continue\n"
  	"					)\n"
  	"				)\n"
  	"\n"
  	"				# If the error can't be fixed by continuing the line, report the error.\n"
  	"				compileError showStack\n"
  	"				lineReader addHistory(line)\n"
  	"				return\n"
  	"			)\n"
  	"\n"
  	"			lineReader addHistory(line)\n"
  	"\n"
  	"			# Execute the line and report any exceptions which happen\n"
  	"			executionError := try(result := context doMessage(lineAsMessage, context))\n"
  	"			if(executionError,\n"
  	"				executionError showStack\n"
  	"				return\n"
  	"			,\n"
  	"				# Write out the command's result\n"
  	"				writeCommandResult(getSlot(\"result\"))\n"
  	"				return\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Z_CLI.io");

	s = "Importer := Object clone do(\n"
  	"	//metadoc Importer description A simple search path based auto-importer.\n"
  	"\n"
  	"	//doc Importer paths List of paths the proto importer will check while searching for protos to load.\n"
  	"	paths := method(FileImporter directories)\n"
  	"\n"
  	"	//doc Importer addSearchPath(path) Add a search path to the auto importer. Relative paths are made absolute before adding.\n"
  	"	addSearchPath    := method(p, paths appendIfAbsent(Path absolute(p) asSymbol))\n"
  	"\n"
  	"	//doc Importer removeSearchPath(path) Removes a search path from the auto importer. Relative paths should be removed from the same working directory as they were added.\n"
  	"	removeSearchPath := method(p, paths remove(Path absolute(p) asSymbol))\n"
  	"\n"
  	"	//doc Importer FileImporter An Importer for local source files.\n"
  	"	FileImporter := Object clone do(\n"
  	"		importsFrom := \"file\"\n"
  	"\n"
  	"		directories := list(\"\")\n"
  	"\n"
  	"		import := method(protoName,\n"
  	"			if(System ?launchPath, directories appendIfAbsent(System launchPath))\n"
  	"			if(System getEnvironmentVariable(\"IOIMPORT\"),\n"
  	"				ioImportEnv := System getEnvironmentVariable(\"IOIMPORT\")\n"
  	"				if(System platform == \"Windows\",\n"
  	"					ioImportEnv split(\";\") foreach(p,\n"
  	"						directories appendIfAbsent(Path absolute(p) asSymbol)\n"
  	"					)\n"
  	"				,\n"
  	"					ioImportEnv split(\":\") foreach(p,\n"
  	"						directories appendIfAbsent(Path absolute(p) asSymbol)\n"
  	"					)\n"
  	"				)\n"
  	"			)\n"
  	"			directories foreach(folder,\n"
  	"				path := Path with(folder, protoName .. \".io\") asSymbol\n"
  	"				if(File with(path) exists,\n"
  	"					//writeln(\"importing: \", path)\n"
  	"					Lobby doFile(path)\n"
  	"					return true\n"
  	"				)\n"
  	"			)\n"
  	"			false\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer AddonImporter An Importer for addon modules.\n"
  	"	AddonImporter := Object clone do(\n"
  	"		importsFrom := \"dll\"\n"
  	"\n"
  	"		import := method(protoName,\n"
  	"			if(hasAddon := AddonLoader hasAddonNamed(protoName),\n"
  	"				AddonLoader loadAddonNamed(protoName)\n"
  	"			)\n"
  	"			hasAddon\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer importers List of Importer objects.\n"
  	"	importers := list(FileImporter, AddonImporter)\n"
  	"\n"
  	"	//doc Importer import(originalCallMessage) Imports an object or addon for the given Message.\n"
  	"	import := method(originalCall,\n"
  	"		protoName := originalCall message name\n"
  	"\n"
  	"		if(protoName at(0) isUppercase and(importer := importers detect(import(protoName))),\n"
  	"			if(Lobby hasSlot(protoName) not,\n"
  	"				Exception raiseFrom(originalCall, \"Importer slot '\" .. protoName .. \"' missing after \" .. importer importsFrom .. \" load\")\n"
  	"			)\n"
  	"			Lobby getSlot(protoName)\n"
  	"		,\n"
  	"			targetType := originalCall target type\n"
  	"			Exception raiseFrom(originalCall, targetType .. \" does not respond to '\" .. protoName .. \"'\")\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer autoImportingForward A forward method implementation placed in the Lobby when Importing is turned on.\n"
  	"	autoImportingForward := method(\n"
  	"		Importer import(call)\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer turnOn Turns on the Importer. Returns self.\n"
  	"	turnOn := method(\n"
  	"		Lobby forward := self getSlot(\"autoImportingForward\")\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer turnOff Turns off the Importer. Returns self.\n"
  	"	turnOff := method(\n"
  	"		Lobby removeSlot(\"forward\")\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	// Auto Importer is on by default\n"
  	"	turnOn\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "Z_Importer.io");

}

